// #include "ntt.h"
// #include "params.h"
// #include "poly.h"
// #include "reduce.h"
// #include <stdint.h>
//
// /* Roots of unity in order needed by forward ntt */
// const uint32_t zetas_asm[N] = {0, 25847, 5771523, 7861508, 237124, 1826347, 2353451, 7602457, 8021166, 6288512, 7504169, 3119733, 5495562, 466468, 3111497, 2680103, 2725464, 2706023, 95776, 1024112, 3077325, 3530437, 7300517, 6718724, 4788269, 3585928, 5842901, 3915439, 7830929, 4519302, 5336701, 7260833, 3574422, 5512770, 2619752, 3539968, 8079950, 6271868, 2348700, 7841118, 6262231, 6681150, 6736599, 4520680, 3505694, 4558682, 6980856, 3507263, 6239768, 5102745, 6779997, 3699596, 1757237, 811944, 531354, 8360995, 954230, 3881043, 4010497, 3900724, 5823537, 280005, 2071892, 5582638, 4450022, 2091667, 3407706, 6851714, 2316500, 3817976, 4702672, 5037939, 2244091, 5339162, 5933984, 4817955, 6927966, 266997, 2434439, 3475950, 7144689, 3513181, 2176455, 4860065, 4621053, 6795196, 7183191, 5187039, 7122806, 900702, 1859098, 1939314, 909542, 819034, 4296819, 495491, 6767243, 7380215, 8337157, 7857917, 5190273, 7725090, 5257975, 5223087, 2031748, 3207046, 4747489, 4823422, 7855319, 126922, 7611795, 4784579, 3412210, 342297, 286988, 7396998, 5942594, 4108315, 2147896, 3437287, 5038140, 2715295, 1735879, 203044, 5412772, 2842341, 2691481, 4686924, 5790267, 1265009, 7969390, 4055324, 1247620, 5903370, 2486353, 1595974, 7709315, 4613401, 1250494, 7151892, 2635921, 4832145, 8357436, 5386378, 1869119, 7072248, 1903435, 7329447, 7998430, 7047359, 1237275, 1349076, 5062207, 6950192, 1852771, 7929317, 1312455, 6949987, 3306115, 6417775, 5037034, 7100756, 1917081, 264944, 5834105, 7005614, 508951, 1500165, 777191, 3097992, 2235880, 3406031, 44288, 7838005, 5548557, 7280319, 6709241, 6533464, 904516, 5796124, 4656147, 3958618, 594136, 4603424, 4656075, 6366809, 2432395, 8371839, 2454455, 8215696, 1653064, 1957272, 3369112, 5130689, 185531, 7173032, 2389356, 5196991, 162844, 8169440, 1616392, 3014001, 759969, 810149, 1652634, 7063561, 4686184, 6581310, 189548, 5341501, 3523897, 4827145, 3866901, 269760, 3159746, 2213111, 7404533, 6529015, 1717735, 472078, 5971092, 7953734, 1723600, 8202977, 6577327, 1910376, 1315589, 6712985, 7276084, 1341330, 8119771, 4546524, 1285669, 5441381, 6144432, 6795489, 7959518, 6094090, 7567685, 183443, 7403526, 6940675, 1612842, 4834730, 5361315, 7826001, 3919660, 4499357, 8332111, 7018208, 4751448, 3937738, 1400424, 3839961, 7534263, 1976782};
//
//
//
// /* Roots of unity in order needed by inverse ntt */
// const uint32_t zetas_inv_asm[N] = {6403635, 846154, 4540456, 6979993, 4442679, 3628969, 1362209, 48306, 3881060, 4460757, 554416, 3019102, 3545687, 6767575, 1439742, 976891, 8196974, 812732, 2286327, 420899, 1584928, 2235985, 2939036, 7094748, 3833893, 260646, 7039087, 1104333, 1667432, 7064828, 6470041, 1803090, 177440, 6656817, 426683, 2409325, 7908339, 6662682, 1851402, 975884, 6167306, 5220671, 8110657, 4513516, 3553272, 4856520, 3038916, 8190869, 1799107, 3694233, 1316856, 6727783, 7570268, 7620448, 5366416, 6764025, 210977, 8217573, 3183426, 5991061, 1207385, 8194886, 3249728, 5011305, 6423145, 6727353, 164721, 5925962, 8578, 5948022, 2013608, 3724342, 3776993, 7786281, 4421799, 3724270, 2584293, 7475901, 1846953, 1671176, 1100098, 2831860, 542412, 8336129, 4974386, 6144537, 5282425, 7603226, 6880252, 7871466, 1374803, 2546312, 8115473, 6463336, 1279661, 3343383, 1962642, 5074302, 1430430, 7067962, 451100, 6527646, 1430225, 3318210, 7031341, 7143142, 1333058, 381987, 1050970, 6476982, 1308169, 6511298, 2994039, 22981, 3548272, 5744496, 1228525, 7129923, 3767016, 671102, 6784443, 5894064, 2477047, 7132797, 4325093, 411027, 7115408, 2590150, 3693493, 5688936, 5538076, 2967645, 8177373, 6644538, 5665122, 3342277, 4943130, 6232521, 4272102, 2437823, 983419, 8093429, 8038120, 4968207, 3595838, 768622, 8253495, 525098, 3556995, 3632928, 5173371, 6348669, 3157330, 3122442, 655327, 3190144, 522500, 43260, 1000202, 1613174, 7884926, 4083598, 7561383, 7470875, 6441103, 6521319, 7479715, 1257611, 3193378, 1197226, 1585221, 3759364, 3520352, 6203962, 4867236, 1235728, 4904467, 5945978, 8113420, 1452451, 3562462, 2446433, 3041255, 6136326, 3342478, 3677745, 4562441, 6063917, 1528703, 4972711, 6288750, 3930395, 2797779, 6308525, 8100412, 2556880, 4479693, 4369920, 4499374, 7426187, 19422, 7849063, 7568473, 6623180, 4680821, 1600420, 3277672, 2140649, 4873154, 1399561, 3821735, 4874723, 3859737, 1643818, 1699267, 2118186, 539299, 6031717, 2108549, 300467, 4840449, 5760665, 2867647, 4805995, 1119584, 3043716, 3861115, 549488, 4464978, 2537516, 4794489, 3592148, 1661693, 1079900, 4849980, 5303092, 7356305, 8284641, 5674394, 5654953, 5700314, 5268920, 7913949, 2884855, 5260684, 876248, 2091905, 359251, 777960, 6026966, 6554070, 8143293, 518909, 2608894, 8354570, 0};

#include <stdint.h>
#include "params.h"
#include "ntt.h"
#include "reduce.h"
#include "randombytes.h"
#include "hal.h"

#define NO_STAGES 8

// NTT protection...

#define NO_PROTECTION 0
#define COARSE_SHUFFLING 1
#define GROUP_COARSE_SHUFFLING 2
#define GROUP_SHUFFLING 4
#define FINE_SHUFFLING 8
#define COARSE_MULTIPLICATIVE_MASKING 16
#define FINE_MULTIPLICATIVE_MASKING 32
#define GENERIC_MULTIPLICATIVE_MASKING 64

#define NTT_PROTECTION_MODE GROUP_SHUFFLING

#define RANDOM_BUFFER_SIZE 4
#define NO_MASKS_IN_STAGE 1


// uint8_t ordered_array[128] = {
//   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
//     20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
//     45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
//     70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,
//     95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115,
//     116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127
//   };

uint8_t multi_ordered_array[8][128] = {
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127}
};

static const uint16_t tree[256] = {
0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88,
216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172,
108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10,
138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214,
54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97,
225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133,
69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61,
189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235,
27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79,
207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255
};

const uint8_t bitrev_order[256] = {
  0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24,
  152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12,
  140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146,
  82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134,
  70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158,
  94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73,
  201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85,
  213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67,
  195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91,
  219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79,
  207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255
};

/* Roots of unity in order needed by forward ntt */
static const uint32_t zetas[N] = {0, 25847, 5771523, 7861508, 237124, 7602457, 7504169, 466468, 1826347, 2353451, 8021166, 6288512, 3119733, 5495562, 3111497, 2680103, 2725464, 1024112, 7300517, 3585928, 7830929, 7260833, 2619752, 6271868, 6262231, 4520680, 6980856, 5102745, 1757237, 8360995, 4010497, 280005, 2706023, 95776, 3077325, 3530437, 6718724, 4788269, 5842901, 3915439, 4519302, 5336701, 3574422, 5512770, 3539968, 8079950, 2348700, 7841118, 6681150, 6736599, 3505694, 4558682, 3507263, 6239768, 6779997, 3699596, 811944, 531354, 954230, 3881043, 3900724, 5823537, 2071892, 5582638, 4450022, 6851714, 4702672, 5339162, 6927966, 3475950, 2176455, 6795196, 7122806, 1939314, 4296819, 7380215, 5190273, 5223087, 4747489, 126922, 3412210, 7396998, 2147896, 2715295, 5412772, 4686924, 7969390, 5903370, 7709315, 7151892, 8357436, 7072248, 7998430, 1349076, 1852771, 6949987, 5037034, 264944, 508951, 3097992, 44288, 7280319, 904516, 3958618, 4656075, 8371839, 1653064, 5130689, 2389356, 8169440, 759969, 7063561, 189548, 4827145, 3159746, 6529015, 5971092, 8202977, 1315589, 1341330, 1285669, 6795489, 7567685, 6940675, 5361315, 4499357, 4751448, 3839961, 2091667, 3407706, 2316500, 3817976, 5037939, 2244091, 5933984, 4817955, 266997, 2434439, 7144689, 3513181, 4860065, 4621053, 7183191, 5187039, 900702, 1859098, 909542, 819034, 495491, 6767243, 8337157, 7857917, 7725090, 5257975, 2031748, 3207046, 4823422, 7855319, 7611795, 4784579, 342297, 286988, 5942594, 4108315, 3437287, 5038140, 1735879, 203044, 2842341, 2691481, 5790267, 1265009, 4055324, 1247620, 2486353, 1595974, 4613401, 1250494, 2635921, 4832145, 5386378, 1869119, 1903435, 7329447, 7047359, 1237275, 5062207, 6950192, 7929317, 1312455, 3306115, 6417775, 7100756, 1917081, 5834105, 7005614, 1500165, 777191, 2235880, 3406031, 7838005, 5548557, 6709241, 6533464, 5796124, 4656147, 594136, 4603424, 6366809, 2432395, 2454455, 8215696, 1957272, 3369112, 185531, 7173032, 5196991, 162844, 1616392, 3014001, 810149, 1652634, 4686184, 6581310, 5341501, 3523897, 3866901, 269760, 2213111, 7404533, 1717735, 472078, 7953734, 1723600, 6577327, 1910376, 6712985, 7276084, 8119771, 4546524, 5441381, 6144432, 7959518, 6094090, 183443, 7403526, 1612842, 4834730, 7826001, 3919660, 8332111, 7018208, 3937738, 1400424, 7534263, 1976782};

/* Roots of unity in order needed by inverse ntt */
static const uint32_t zetas_inv[N] = {6403635, 846154, 6979993, 4442679, 1362209, 48306, 4460757, 554416, 3545687, 6767575, 976891, 8196974, 2286327, 420899, 2235985, 2939036, 3833893, 260646, 1104333, 1667432, 6470041, 1803090, 6656817, 426683, 7908339, 6662682, 975884, 6167306, 8110657, 4513516, 4856520, 3038916, 1799107, 3694233, 6727783, 7570268, 5366416, 6764025, 8217573, 3183426, 1207385, 8194886, 5011305, 6423145, 164721, 5925962, 5948022, 2013608, 3776993, 7786281, 3724270, 2584293, 1846953, 1671176, 2831860, 542412, 4974386, 6144537, 7603226, 6880252, 1374803, 2546312, 6463336, 1279661, 1962642, 5074302, 7067962, 451100, 1430225, 3318210, 7143142, 1333058, 1050970, 6476982, 6511298, 2994039, 3548272, 5744496, 7129923, 3767016, 6784443, 5894064, 7132797, 4325093, 7115408, 2590150, 5688936, 5538076, 8177373, 6644538, 3342277, 4943130, 4272102, 2437823, 8093429, 8038120, 3595838, 768622, 525098, 3556995, 5173371, 6348669, 3122442, 655327, 522500, 43260, 1613174, 7884926, 7561383, 7470875, 6521319, 7479715, 3193378, 1197226, 3759364, 3520352, 4867236, 1235728, 5945978, 8113420, 3562462, 2446433, 6136326, 3342478, 4562441, 6063917, 4972711, 6288750, 4540456, 3628969, 3881060, 3019102, 1439742, 812732, 1584928, 7094748, 7039087, 7064828, 177440, 2409325, 1851402, 5220671, 3553272, 8190869, 1316856, 7620448, 210977, 5991061, 3249728, 6727353, 8578, 3724342, 4421799, 7475901, 1100098, 8336129, 5282425, 7871466, 8115473, 3343383, 1430430, 6527646, 7031341, 381987, 1308169, 22981, 1228525, 671102, 2477047, 411027, 3693493, 2967645, 5665122, 6232521, 983419, 4968207, 8253495, 3632928, 3157330, 3190144, 1000202, 4083598, 6441103, 1257611, 1585221, 6203962, 4904467, 1452451, 3041255, 3677745, 1528703, 3930395, 2797779, 6308525, 2556880, 4479693, 4499374, 7426187, 7849063, 7568473, 4680821, 1600420, 2140649, 4873154, 3821735, 4874723, 1643818, 1699267, 539299, 6031717, 300467, 4840449, 2867647, 4805995, 3043716, 3861115, 4464978, 2537516, 3592148, 1661693, 4849980, 5303092, 8284641, 5674394, 8100412, 4369920, 19422, 6623180, 3277672, 1399561, 3859737, 2118186, 2108549, 5760665, 1119584, 549488, 4794489, 1079900, 7356305, 5654953, 5700314, 5268920, 2884855, 5260684, 2091905, 359251, 6026966, 6554070, 7913949, 876248, 777960, 8143293, 518909, 2608894, 8354570};

static const uint32_t zetas_normal_order[2*N] = {
4193792, 2091667, 4450022, 7100756, 2706023, 342297, 5037034, 5341501, 2725464, 900702, 3412210, 6366809, 6681150, 4613401, 189548, 5441381, 1826347, 266997, 7122806, 7838005, 4519302, 2842341, 4656075, 7953734, 6262231, 7725090, 7709315, 5196991, 811944, 7047359, 1285669, 7826001, 237124, 5037939, 6927966, 1500165, 6718724, 3437287, 44288, 2213111, 7830929, 495491, 5412772, 1957272, 3507263, 5386378, 5971092, 183443, 3119733, 4860065, 5190273, 5796124, 3539968, 4055324, 2389356, 6712985, 1757237, 4823422, 7998430, 810149, 3900724, 7929317, 5361315, 3937738, 5771523, 2316500, 4702672, 5834105, 3077325, 5942594, 508951, 3866901, 7300517, 909542, 2147896, 2454455, 3505694, 2635921, 3159746, 7959518, 8021166, 7144689, 4296819, 6709241, 3574422, 5790267, 1653064, 6577327, 6980856, 2031748, 8357436, 1616392, 954230, 5062207, 7567685, 8332111, 7504169, 5933984, 2176455, 2235880, 5842901, 1735879, 904516, 1717735, 2619752, 8337157, 7969390, 185531, 6779997, 1903435, 1315589, 1612842, 3111497, 7183191, 4747489, 594136, 2348700, 2486353, 759969, 8119771, 4010497, 7611795, 1852771, 4686184, 2071892, 3306115, 4751448, 7534263, 25847, 3407706, 6851714, 1917081, 95776, 286988, 264944, 3523897, 1024112, 1859098, 7396998, 2432395, 6736599, 1250494, 4827145, 6144432, 2353451, 2434439, 1939314, 5548557, 5336701, 2691481, 8371839, 1723600, 4520680, 5257975, 7151892, 162844, 531354, 1237275, 6795489, 3919660, 7602457, 2244091, 3475950, 777191, 4788269, 5038140, 7280319, 7404533, 7260833, 6767243, 4686924, 3369112, 6239768, 1869119, 8202977, 7403526, 5495562, 4621053, 5223087, 4656147, 8079950, 1247620, 8169440, 7276084, 8360995, 7855319, 1349076, 1652634, 5823537, 1312455, 4499357, 1400424, 7861508, 3817976, 5339162, 7005614, 3530437, 4108315, 3097992, 269760, 3585928, 819034, 2715295, 8215696, 4558682, 4832145, 6529015, 6094090, 6288512, 3513181, 7380215, 6533464, 5512770, 1265009, 5130689, 1910376, 5102745, 3207046, 7072248, 3014001, 3881043, 6950192, 6940675, 7018208, 466468, 4817955, 6795196, 3406031, 3915439, 203044, 3958618, 472078, 6271868, 7857917, 5903370, 7173032, 3699596, 7329447, 1341330, 4834730, 2680103, 5187039, 126922, 4603424, 7841118, 1595974, 7063561, 4546524, 280005, 4784579, 6949987, 6581310, 5582638, 6417775, 3839961, 1976782, 4186625, 6288750, 3930395, 1279661, 5674394, 8038120, 3343383, 3038916, 5654953, 7479715, 4968207, 2013608, 1699267, 3767016, 8190869, 2939036, 6554070, 8113420, 1257611, 542412, 3861115, 5538076, 3724342, 426683, 2118186, 655327, 671102, 3183426, 7568473, 1333058, 7094748, 554416, 8143293, 3342478, 1452451, 6880252, 1661693, 4943130, 8336129, 6167306, 549488, 7884926, 2967645, 6423145, 4873154, 2994039, 2409325, 8196974, 5260684, 3520352, 3190144, 2584293, 4840449, 4325093, 5991061, 1667432, 6623180, 3556995, 381987, 7570268, 4479693, 451100, 3019102, 4442679, 2608894, 6063917, 3677745, 2546312, 5303092, 2437823, 7871466, 4513516, 1079900, 7470875, 6232521, 5925962, 4874723, 5744496, 5220671, 420899, 359251, 1235728, 4083598, 1671176, 4805995, 2590150, 6727353, 1803090, 1399561, 6348669, 22981, 6764025, 7426187, 3318210, 812732, 48306, 876248, 2446433, 6203962, 6144537, 2537516, 6644538, 7475901, 6662682, 5760665, 43260, 411027, 8194886, 1600420, 6476982, 7064828, 6767575, 5268920, 1197226, 3632928, 7786281, 6031717, 5894064, 7620448, 260646, 4369920, 768622, 6527646, 3694233, 6308525, 5074302, 3628969, 846154, 8354570, 4972711, 1528703, 6463336, 8284641, 8093429, 8115473, 4856520, 7356305, 6521319, 983419, 5948022, 1643818, 7129923, 3553272, 2235985, 6026966, 5945978, 6441103, 2831860, 3043716, 5688936, 8578, 6656817, 3859737, 3122442, 1228525, 8217573, 7849063, 7143142, 1584928, 4460757, 777960, 6136326, 4904467, 7603226, 3592148, 3342277, 1100098, 975884, 1119584, 1613174, 3693493, 5011305, 2140649, 6511298, 177440, 976891, 2884855, 3759364, 3157330, 3724270, 300467, 7132797, 210977, 1104333, 19422, 525098, 7031341, 6727783, 2556880, 7067962, 3881060, 6979993, 518909, 4562441, 3041255, 1374803, 4849980, 4272102, 5282425, 8110657, 4794489, 7561383, 5665122, 164721, 3821735, 3548272, 1851402, 2286327, 2091905, 4867236, 1000202, 1846953, 2867647, 7115408, 3249728, 6470041, 3277672, 5173371, 1308169, 5366416, 4499374, 1430225, 1439742, 1362209, 7913949, 3562462, 1585221, 4974386, 4464978, 8177373, 4421799, 7908339, 2108549, 522500, 2477047, 1207385, 4680821, 1050970, 7039087, 3545687, 5700314, 3193378, 8253495, 3776993, 539299, 6784443, 1316856, 3833893, 8100412, 3595838, 1430430, 1799107, 2797779, 1962642, 4540456, 6403635
};

static const uint8_t index_array[8][128] = {
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127},
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191},
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223},
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239},
    {0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23, 32, 33, 34, 35, 36, 37, 38, 39, 48, 49, 50, 51, 52, 53, 54, 55, 64, 65, 66, 67, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 96, 97, 98, 99, 100, 101, 102, 103, 112, 113, 114, 115, 116, 117, 118, 119, 128, 129, 130, 131, 132, 133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 151, 160, 161, 162, 163, 164, 165, 166, 167, 176, 177, 178, 179, 180, 181, 182, 183, 192, 193, 194, 195, 196, 197, 198, 199, 208, 209, 210, 211, 212, 213, 214, 215, 224, 225, 226, 227, 228, 229, 230, 231, 240, 241, 242, 243, 244, 245, 246, 247},
    {0, 1, 2, 3, 8, 9, 10, 11, 16, 17, 18, 19, 24, 25, 26, 27, 32, 33, 34, 35, 40, 41, 42, 43, 48, 49, 50, 51, 56, 57, 58, 59, 64, 65, 66, 67, 72, 73, 74, 75, 80, 81, 82, 83, 88, 89, 90, 91, 96, 97, 98, 99, 104, 105, 106, 107, 112, 113, 114, 115, 120, 121, 122, 123, 128, 129, 130, 131, 136, 137, 138, 139, 144, 145, 146, 147, 152, 153, 154, 155, 160, 161, 162, 163, 168, 169, 170, 171, 176, 177, 178, 179, 184, 185, 186, 187, 192, 193, 194, 195, 200, 201, 202, 203, 208, 209, 210, 211, 216, 217, 218, 219, 224, 225, 226, 227, 232, 233, 234, 235, 240, 241, 242, 243, 248, 249, 250, 251},
    {0, 1, 4, 5, 8, 9, 12, 13, 16, 17, 20, 21, 24, 25, 28, 29, 32, 33, 36, 37, 40, 41, 44, 45, 48, 49, 52, 53, 56, 57, 60, 61, 64, 65, 68, 69, 72, 73, 76, 77, 80, 81, 84, 85, 88, 89, 92, 93, 96, 97, 100, 101, 104, 105, 108, 109, 112, 113, 116, 117, 120, 121, 124, 125, 128, 129, 132, 133, 136, 137, 140, 141, 144, 145, 148, 149, 152, 153, 156, 157, 160, 161, 164, 165, 168, 169, 172, 173, 176, 177, 180, 181, 184, 185, 188, 189, 192, 193, 196, 197, 200, 201, 204, 205, 208, 209, 212, 213, 216, 217, 220, 221, 224, 225, 228, 229, 232, 233, 236, 237, 240, 241, 244, 245, 248, 249, 252, 253},
    {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254}
};

static const uint8_t twiddle_factor_index_array[8][128] = {
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
    {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7},
    {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
    {16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31},
    {32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58, 58, 59, 59, 59, 59, 60, 60, 60, 60, 61, 61, 61, 61, 62, 62, 62, 62, 63, 63, 63, 63},
    {64, 64, 65, 65, 66, 66, 67, 67, 68, 68, 69, 69, 70, 70, 71, 71, 72, 72, 73, 73, 74, 74, 75, 75, 76, 76, 77, 77, 78, 78, 79, 79, 80, 80, 81, 81, 82, 82, 83, 83, 84, 84, 85, 85, 86, 86, 87, 87, 88, 88, 89, 89, 90, 90, 91, 91, 92, 92, 93, 93, 94, 94, 95, 95, 96, 96, 97, 97, 98, 98, 99, 99, 100, 100, 101, 101, 102, 102, 103, 103, 104, 104, 105, 105, 106, 106, 107, 107, 108, 108, 109, 109, 110, 110, 111, 111, 112, 112, 113, 113, 114, 114, 115, 115, 116, 116, 117, 117, 118, 118, 119, 119, 120, 120, 121, 121, 122, 122, 123, 123, 124, 124, 125, 125, 126, 126, 127, 127},
    {128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
};

static const uint8_t inverse_index_array[8][128] = {
  {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254},
  {0, 1, 4, 5, 8, 9, 12, 13, 16, 17, 20, 21, 24, 25, 28, 29, 32, 33, 36, 37, 40, 41, 44, 45, 48, 49, 52, 53, 56, 57, 60, 61, 64, 65, 68, 69, 72, 73, 76, 77, 80, 81, 84, 85, 88, 89, 92, 93, 96, 97, 100, 101, 104, 105, 108, 109, 112, 113, 116, 117, 120, 121, 124, 125, 128, 129, 132, 133, 136, 137, 140, 141, 144, 145, 148, 149, 152, 153, 156, 157, 160, 161, 164, 165, 168, 169, 172, 173, 176, 177, 180, 181, 184, 185, 188, 189, 192, 193, 196, 197, 200, 201, 204, 205, 208, 209, 212, 213, 216, 217, 220, 221, 224, 225, 228, 229, 232, 233, 236, 237, 240, 241, 244, 245, 248, 249, 252, 253},
  {0, 1, 2, 3, 8, 9, 10, 11, 16, 17, 18, 19, 24, 25, 26, 27, 32, 33, 34, 35, 40, 41, 42, 43, 48, 49, 50, 51, 56, 57, 58, 59, 64, 65, 66, 67, 72, 73, 74, 75, 80, 81, 82, 83, 88, 89, 90, 91, 96, 97, 98, 99, 104, 105, 106, 107, 112, 113, 114, 115, 120, 121, 122, 123, 128, 129, 130, 131, 136, 137, 138, 139, 144, 145, 146, 147, 152, 153, 154, 155, 160, 161, 162, 163, 168, 169, 170, 171, 176, 177, 178, 179, 184, 185, 186, 187, 192, 193, 194, 195, 200, 201, 202, 203, 208, 209, 210, 211, 216, 217, 218, 219, 224, 225, 226, 227, 232, 233, 234, 235, 240, 241, 242, 243, 248, 249, 250, 251},
  {0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23, 32, 33, 34, 35, 36, 37, 38, 39, 48, 49, 50, 51, 52, 53, 54, 55, 64, 65, 66, 67, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 96, 97, 98, 99, 100, 101, 102, 103, 112, 113, 114, 115, 116, 117, 118, 119, 128, 129, 130, 131, 132, 133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 151, 160, 161, 162, 163, 164, 165, 166, 167, 176, 177, 178, 179, 180, 181, 182, 183, 192, 193, 194, 195, 196, 197, 198, 199, 208, 209, 210, 211, 212, 213, 214, 215, 224, 225, 226, 227, 228, 229, 230, 231, 240, 241, 242, 243, 244, 245, 246, 247},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127}
};

static const uint8_t inverse_twiddle_factor_index_array[8][128] = {
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127},
  {128, 128, 129, 129, 130, 130, 131, 131, 132, 132, 133, 133, 134, 134, 135, 135, 136, 136, 137, 137, 138, 138, 139, 139, 140, 140, 141, 141, 142, 142, 143, 143, 144, 144, 145, 145, 146, 146, 147, 147, 148, 148, 149, 149, 150, 150, 151, 151, 152, 152, 153, 153, 154, 154, 155, 155, 156, 156, 157, 157, 158, 158, 159, 159, 160, 160, 161, 161, 162, 162, 163, 163, 164, 164, 165, 165, 166, 166, 167, 167, 168, 168, 169, 169, 170, 170, 171, 171, 172, 172, 173, 173, 174, 174, 175, 175, 176, 176, 177, 177, 178, 178, 179, 179, 180, 180, 181, 181, 182, 182, 183, 183, 184, 184, 185, 185, 186, 186, 187, 187, 188, 188, 189, 189, 190, 190, 191, 191},
  {192, 192, 192, 192, 193, 193, 193, 193, 194, 194, 194, 194, 195, 195, 195, 195, 196, 196, 196, 196, 197, 197, 197, 197, 198, 198, 198, 198, 199, 199, 199, 199, 200, 200, 200, 200, 201, 201, 201, 201, 202, 202, 202, 202, 203, 203, 203, 203, 204, 204, 204, 204, 205, 205, 205, 205, 206, 206, 206, 206, 207, 207, 207, 207, 208, 208, 208, 208, 209, 209, 209, 209, 210, 210, 210, 210, 211, 211, 211, 211, 212, 212, 212, 212, 213, 213, 213, 213, 214, 214, 214, 214, 215, 215, 215, 215, 216, 216, 216, 216, 217, 217, 217, 217, 218, 218, 218, 218, 219, 219, 219, 219, 220, 220, 220, 220, 221, 221, 221, 221, 222, 222, 222, 222, 223, 223, 223, 223},
  {224, 224, 224, 224, 224, 224, 224, 224, 225, 225, 225, 225, 225, 225, 225, 225, 226, 226, 226, 226, 226, 226, 226, 226, 227, 227, 227, 227, 227, 227, 227, 227, 228, 228, 228, 228, 228, 228, 228, 228, 229, 229, 229, 229, 229, 229, 229, 229, 230, 230, 230, 230, 230, 230, 230, 230, 231, 231, 231, 231, 231, 231, 231, 231, 232, 232, 232, 232, 232, 232, 232, 232, 233, 233, 233, 233, 233, 233, 233, 233, 234, 234, 234, 234, 234, 234, 234, 234, 235, 235, 235, 235, 235, 235, 235, 235, 236, 236, 236, 236, 236, 236, 236, 236, 237, 237, 237, 237, 237, 237, 237, 237, 238, 238, 238, 238, 238, 238, 238, 238, 239, 239, 239, 239, 239, 239, 239, 239},
  {240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 243, 243, 243, 243, 243, 243, 243, 243, 243, 243, 243, 243, 243, 243, 243, 243, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247},
  {248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251},
  {252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253},
  {254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254}
};

static const uint16_t inverse_zeta_order[256] = {
      511, 383, 447, 319, 479, 351, 415, 287, 495, 367, 431, 303, 463, 335, 399, 271, 503, 375, 439, 311, 471, 343, 407, 279,
      487, 359, 423, 295, 455, 327, 391, 263, 507, 379, 443, 315, 475, 347, 411, 283, 491, 363, 427, 299, 459, 331, 395, 267,
      499, 371, 435, 307, 467, 339, 403, 275, 483, 355, 419, 291, 451, 323, 387, 259, 509, 381, 445, 317, 477, 349, 413, 285,
      493, 365, 429, 301, 461, 333, 397, 269, 501, 373, 437, 309, 469, 341, 405, 277, 485, 357, 421, 293, 453, 325, 389, 261,
      505, 377, 441, 313, 473, 345, 409, 281, 489, 361, 425, 297, 457, 329, 393, 265, 497, 369, 433, 305, 465, 337, 401, 273,
      481, 353, 417, 289, 449, 321, 385, 257, 510, 382, 446, 318, 478, 350, 414, 286, 494, 366, 430, 302, 462, 334, 398, 270,
      502, 374, 438, 310, 470, 342, 406, 278, 486, 358, 422, 294, 454, 326, 390, 262, 506, 378, 442, 314, 474, 346, 410, 282,
      490, 362, 426, 298, 458, 330, 394, 266, 498, 370, 434, 306, 466, 338, 402, 274, 482, 354, 418, 290, 450, 322, 386, 258,
      508, 380, 444, 316, 476, 348, 412, 284, 492, 364, 428, 300, 460, 332, 396, 268, 500, 372, 436, 308, 468, 340, 404, 276,
      484, 356, 420, 292, 452, 324, 388, 260, 504, 376, 440, 312, 472, 344, 408, 280, 488, 360, 424, 296, 456, 328, 392, 264,
      496, 368, 432, 304, 464, 336, 400, 272, 480, 352, 416, 288, 448, 320, 384
};

// Calculate reversebits of a number (Count means the number of bits in the number)
static int reverseBits(int num, int count)
{
    int mask = 0x1FF;
    num = num & mask;
    int reverse_num = 0;
    char bit=0;
    for(int i=count-1;i>=0;i--)
    {
        bit=(num&0b1);
        reverse_num = reverse_num + (bit<<i);
        num >>=1;
    }
    return reverse_num;
}

static int shift_lfsr(unsigned int *lfsr, unsigned int polynomial_mask)
{
    int feedback;

    feedback = *lfsr & 1;
    *lfsr >>= 1;
    if(feedback == 1)
        *lfsr ^= polynomial_mask;
    return *lfsr;
}

static int get_random(void)
{
    int temp;
    unsigned int POLY_MASK_HERE_1 = 0xB765879A;
    unsigned int POLY_MASK_HERE_2 = 0x55BBEEFF;
    static unsigned int lfsr_1 = 0x55AAEEFF;
    static unsigned int lfsr_2 = 0xFFAA8844;
    shift_lfsr(&lfsr_1, POLY_MASK_HERE_1);
    shift_lfsr(&lfsr_2, POLY_MASK_HERE_2);
    temp = (shift_lfsr(&lfsr_1, POLY_MASK_HERE_1) ^ shift_lfsr(&lfsr_2, POLY_MASK_HERE_2)) & 0XFF;
    // printf("%02x\n",temp);
    return (temp);
}

// A utility function to swap to integers
static void swap (unsigned char *a, unsigned char *b)
{
    unsigned char temp = *a;
    *a = *b;
    *b = temp;
}

extern unsigned long long randomize_ntt_time, t0_ntt, t1_ntt;
extern unsigned long long randomize_intt_time, t0_intt, t1_intt;

unsigned char random_buffer[RANDOM_BUFFER_SIZE];
unsigned int total_rand_bytes_remaining = 0;
unsigned int total_rand_bits_remaining = 0;
uint32_t random_index_global;
uint16_t spare_random;
uint8_t spare_random_length;

// A function to generate a random
// permutation of arr[]
static void randomize (unsigned char arr[], int n)
{
  unsigned char temp;
    // Start from the last element and swap
    // one by one. We don't need to run for
    // the first element that's why i > 0
    for (int i = n - 1; i > 0; i--)
    {
        // // randombytes(&temp,1);
        // temp = get_random();
        if(total_rand_bytes_remaining <= 0)
        {

          #if(CALC_NTT_RAND_TIME_RAND == 1)
            t0_ntt = hal_get_time();
          #endif

          randombytes(random_buffer,RANDOM_BUFFER_SIZE);
          // prf(random_buffer, RANDOM_BUFFER_SIZE, seed, 0);
          total_rand_bytes_remaining = RANDOM_BUFFER_SIZE;

          #if(CALC_NTT_RAND_TIME_RAND == 1)

            t1_ntt = hal_get_time();
            randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;

          #endif
        }

        temp = random_buffer[RANDOM_BUFFER_SIZE-total_rand_bytes_remaining];
        total_rand_bytes_remaining = total_rand_bytes_remaining-1;

        // Pick a random index from 0 to i
        int j = temp % (i + 1);

        // Swap arr[i] with the element
        // at random index
        // swap(&arr[i], &arr[j]);
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

// A function to generate a random
// permutation of arr[]
static void randomize_i (unsigned char arr[], int n)
{
  unsigned char temp;
    // Start from the last element and swap
    // one by one. We don't need to run for
    // the first element that's why i > 0
    for (int i = n - 1; i > 0; i--)
    {
        // // randombytes(&temp,1);
        // temp = get_random();

        if(total_rand_bytes_remaining <= 0)
        {

          #if(CALC_NTT_RAND_TIME_RAND == 1)
            t0_intt = hal_get_time();
          #endif

          randombytes(random_buffer,RANDOM_BUFFER_SIZE);
          // prf(random_buffer, RANDOM_BUFFER_SIZE, seed, 0);
          total_rand_bytes_remaining = RANDOM_BUFFER_SIZE;

          #if(CALC_NTT_RAND_TIME_RAND == 1)

            t1_intt = hal_get_time();
            randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;

          #endif
        }
        temp = random_buffer[RANDOM_BUFFER_SIZE-total_rand_bytes_remaining];
        total_rand_bytes_remaining = total_rand_bytes_remaining-1;

        // Pick a random index from 0 to i
        int j = temp % (i + 1);

        // Swap arr[i] with the element
        // at random index
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

/*************************************************
* Name:        ntt
*
* Description: Forward NTT, in-place. No modular reduction is performed after
*              additions or subtractions. If input coefficients are below 2*Q,
*              then output coefficients are below 18*Q.
*              Output vector is in bitreversed order.
*
* Arguments:   - uint32_t p[N]: input/output coefficient array
**************************************************/

void ntt_no_protect(uint32_t p[N])
{
  // #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
  //   randomize_ntt_time = 0;
  // #endif

  unsigned int len, start, j, k;
  uint32_t zeta, t;

  k = 1;
  for(len = 128; len > 0; len >>= 1)
  {
    for(start = 0; start < N; start = j + len)
    {
      zeta = zetas[k++];
      for(j = start; j < start + len; ++j)
      {
        t = montgomery_reduce((uint64_t)zeta * p[j + len]);
        p[j + len] = p[j] + 2*Q - t;
        p[j] = p[j] + t;
      }
    }
  }
}

#if (NTT_PROTECTION_MODE == NO_PROTECTION)

void ntt(uint32_t p[N])
{
  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_ntt_time = 0;
  #endif

  unsigned int len, start, j, k;
  uint32_t zeta, t;

  k = 1;
  for(len = 128; len > 0; len >>= 1)
  {
    for(start = 0; start < N; start = j + len)
    {
      zeta = zetas[k++];
      for(j = start; j < start + len; ++j)
      {
        t = montgomery_reduce((uint64_t)zeta * p[j + len]);
        p[j + len] = p[j] + 2*Q - t;
        p[j] = p[j] + t;
      }
    }
  }
}

#elif (NTT_PROTECTION_MODE == GROUP_COARSE_SHUFFLING)

// Coarse Shuffling within groups...

void ntt(uint32_t p[N])
{

  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_ntt_time = 0;
  #endif

  unsigned int len, start, j, k;
  uint32_t zeta, t;
  uint8_t len1,temp;

  k = 1;
  uint8_t stage = 0;
  for(len = 8; len > 0; len--)
  {
      len1 = 1 << (len-1);
      if(len > 1)
      {
        for(start = 0; start < N; start = j + len1)
        {
            zeta = zetas[k++];

            #if(CALC_NTT_RAND_TIME == 1)
            t0_ntt = hal_get_time();
            #endif

            randomize(&(multi_ordered_array[len-1][0]), len1);

            #if(CALC_NTT_RAND_TIME == 1)
            t1_ntt = hal_get_time();
            randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;
            #endif

            for(j = start; j < start + len1; ++j)
            {
              temp = multi_ordered_array[len-1][j-start] + start;

              t = montgomery_reduce((uint64_t)zeta * p[temp + len1]);
              p[temp + len1] = p[temp] + 2*Q - t;
              p[temp] = p[temp] + t;
            }
         }
       }
       else
       {
           #if(CALC_NTT_RAND_TIME == 1)
           t0_ntt = hal_get_time();
           #endif

           randomize(&(multi_ordered_array[7][0]), 128);

           #if(CALC_NTT_RAND_TIME == 1)
           t1_ntt = hal_get_time();
           randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;
           #endif

           for(start = 0; start < 128; start++)
           {
             temp = multi_ordered_array[7][start];
             zeta = zetas[twiddle_factor_index_array[stage][temp]];
             temp = index_array[stage][temp];

             t = montgomery_reduce((uint64_t)zeta * p[temp + len1]);
             p[temp + len1] = p[temp] + 2*Q - t;
             p[temp] = p[temp] + t;

           }
        }
        stage = stage+1;
   }
}

#elif (NTT_PROTECTION_MODE == COARSE_SHUFFLING)

// Coarse Shuffling...

void ntt(uint32_t p[N])
{
  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_ntt_time = 0;
  #endif

  unsigned int len, start, j, k;
  uint32_t zeta, t;
  uint8_t temp;

  k = 1;
  uint8_t stage = 0;
  for(len = 128; len > 0; len >>= 1)
  {
    #if(CALC_NTT_RAND_TIME == 1)
    t0_ntt = hal_get_time();
    #endif

    randomize(&(multi_ordered_array[7][0]), 128);

    #if(CALC_NTT_RAND_TIME == 1)

    t1_ntt = hal_get_time();
    randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;
    #endif

    for(start = 0; start < 128; start++)
    {
      temp = multi_ordered_array[7][start];
      zeta = zetas[twiddle_factor_index_array[stage][temp]];
      temp = index_array[stage][temp];

      t = montgomery_reduce((uint64_t)zeta * p[temp + len]);
      p[temp + len] = p[temp] + 2*Q - t;
      p[temp] = p[temp] + t;

    }
    stage = stage+1;
  }
}

#elif (NTT_PROTECTION_MODE == GROUP_SHUFFLING)

void ntt(uint32_t p[N])
{
  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_ntt_time = 0;
  #endif

  unsigned int start, j, k;
  uint32_t zeta, t;
  uint8_t len1,temp,no_groups,row_no,stage,g;
  signed int len;

  k = 1;
  stage = 0;
  for(len = 7; len >= 0; len--)
  {
    len1 = (1 << len);
    no_groups = 128/len1;
    row_no = 7 - len;

    if(no_groups > 1)
    {
      #if(CALC_NTT_RAND_TIME == 1)
      t0_ntt = hal_get_time();
      #endif

      randomize(&(multi_ordered_array[row_no][0]), no_groups);

      #if(CALC_NTT_RAND_TIME == 1)
      t1_ntt = hal_get_time();
      randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;
      #endif

      for(g = 0; g < no_groups; g++)
      {
        start = (multi_ordered_array[row_no][g])*2*len1;
        zeta = zetas[twiddle_factor_index_array[stage][start/2]];

        for(j = start; j < start + len1; ++j)
        {
          t = montgomery_reduce((uint64_t)zeta * p[j + len1]);
          p[j + len1] = p[j] + 2*Q - t;
          p[j] = p[j] + t;
        }
      }
    }
    else
    {
        #if(CALC_NTT_RAND_TIME == 1)
        t0_ntt = hal_get_time();
        #endif

        randomize(&(multi_ordered_array[7][0]), 128);

        #if(CALC_NTT_RAND_TIME == 1)
        t1_ntt = hal_get_time();
        randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;
        #endif

        for(start = 0; start < 128; start++)
        {
          temp = multi_ordered_array[7][start];
          zeta = zetas[twiddle_factor_index_array[stage][temp]];
          temp = index_array[stage][temp];

          t = montgomery_reduce((uint64_t)zeta * p[temp + len1]);
          p[temp + len1] = p[temp] + 2*Q - t;
          p[temp] = p[temp] + t;
        }
    }
    stage = stage+1;
  }
}

#elif (NTT_PROTECTION_MODE == FINE_SHUFFLING)

// Fine Shuffling...

void ntt(uint32_t p[N])
{
  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_ntt_time = 0;
  #endif

  unsigned int len, start, j, k;
  uint32_t zeta, t;
  uint32_t op1, op2, temp, out1, out2, temp_new;
  uint8_t randi, bitrand;
  uint32_t mask;

  uint32_t op1_new, op2_new;
  uint8_t op1_new_bit, op2_new_bit, bit;

  int count = 0;

  total_rand_bytes_remaining = 0;
  count = 32;

  k = 1;
  for(len = 128; len > 0; len >>= 1)
  {
    for(start = 0; start < N; start = j + len)
    {
      zeta = zetas[k++];
      for(j = start; j < start + len; ++j)
      {
        // if((count&0x7) == 0)
        // {
        //   randi = get_random();
        // }

        if(count == 32)
        {

          #if(CALC_NTT_RAND_TIME_RAND == 1)
            t0_ntt = hal_get_time();
          #endif

          randombytes(random_buffer,RANDOM_BUFFER_SIZE);
          // prf(random_buffer, RANDOM_BUFFER_SIZE, seed, 0);
          total_rand_bytes_remaining = RANDOM_BUFFER_SIZE;

          #if(CALC_NTT_RAND_TIME_RAND == 1)

            t1_ntt = hal_get_time();
            randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;

          #endif

          count = 0;
        }

        randi = random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining];

        if(count > 0 && (count & 0xFF) == 0)
          total_rand_bytes_remaining = total_rand_bytes_remaining-1;

        bitrand = randi>>(count&0x7)&0x1;

        op1 = p[j+bitrand*len];
        op2 = p[j+(1-bitrand)*len];

        // count = count+1;

        #if(CALC_NTT_RAND_TIME == 1)
        t0_ntt = hal_get_time();
        #endif

        count = count+1;
        // mask = -1*(bitrand);

        // // cswap...
        // temp = (op1 ^ op2)&mask;
        // op1 = op1 ^ temp;
        // op2 = op2 ^ temp;

        temp = (op1 ^ op2);

        // op1_new = 0;
        // op2_new = 0;
        //
        // for(int cc = 0; cc < 32; cc++)
        // {
        //   bit = ((temp >> cc) & 1) & bitrand;
        //   op1_new_bit = ((op1 >> cc) & 1) ^ bit;
        //   op2_new_bit = ((op2 >> cc) & 1) ^ bit;
        //   op1_new |= (op1_new_bit << cc);
        //   op2_new |= (op2_new_bit << cc);
        // }
        //
        // op1 = op1_new;
        // op2 = op2_new;

        temp_new = 0;

        for(int cc = 0; cc < 32; cc++)
        {
          bit = ((temp >> cc)) & bitrand;
          temp_new |= (bit << cc);
        }

        op1 = op1 ^ temp_new;
        op2 = op2 ^ temp_new;

        #if(CALC_NTT_RAND_TIME == 1)
        t1_ntt = hal_get_time();
        randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;
        #endif

        t = montgomery_reduce((uint64_t)zeta * op2);
        out2 = op1 + 2*Q - t;
        out1 = op1 + t;

        // if((count&0x7) == 0)
        // {
        //   randi = get_random();
        // }

        if(count == 32)
        {

          #if(CALC_NTT_RAND_TIME_RAND == 1)
            t0_ntt = hal_get_time();
          #endif

          randombytes(random_buffer,RANDOM_BUFFER_SIZE);
          // prf(random_buffer, RANDOM_BUFFER_SIZE, seed, 0);
          total_rand_bytes_remaining = RANDOM_BUFFER_SIZE;

          #if(CALC_NTT_RAND_TIME_RAND == 1)

            t1_ntt = hal_get_time();
            randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;

          #endif

          count = 0;
        }

        randi = random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining];

        if(count > 0 && (count & 0xFF) == 0)
          total_rand_bytes_remaining = total_rand_bytes_remaining-1;


        // mask = -1*(bitrand);
        // count = count+1;

        #if(CALC_NTT_RAND_TIME == 1)
        t0_ntt = hal_get_time();
        #endif

        bitrand = randi>>(count&0x7)&0x1;
        count = count+1;

        // temp = (out1 ^ out2)&mask;
        // out1 = out1 ^ temp;
        // out2 = out2 ^ temp;

        temp = (out1 ^ out2);

        // op1_new = 0;
        // op2_new = 0;
        //
        // for(int cc = 0; cc < 32; cc++)
        // {
        //   bit = ((temp >> cc) & 1) & bitrand;
        //   op1_new_bit = ((out1 >> cc) & 1) ^ bit;
        //   op2_new_bit = ((out2 >> cc) & 1) ^ bit;
        //   op1_new |= (op1_new_bit << cc);
        //   op2_new |= (op2_new_bit << cc);
        // }
        //
        // out1 = op1_new;
        // out2 = op2_new;

        temp_new = 0;

        for(int cc = 0; cc < 32; cc++)
        {
          bit = ((temp >> cc)) & bitrand;
          temp_new |= (bit << cc);
        }

        out1 = out1 ^ temp_new;
        out2 = out2 ^ temp_new;

        #if(CALC_NTT_RAND_TIME == 1)
        t1_ntt = hal_get_time();
        randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;
        #endif

        p[j+(bitrand)*len] = out1;
        p[j+(1-bitrand)*len] = out2;

      }
    }
  }
}

#elif (NTT_PROTECTION_MODE == COARSE_MULTIPLICATIVE_MASKING)

// Coarse multiplicative Masking...

void ntt(uint32_t p[N])
{
  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_ntt_time = 0;
  #endif

  unsigned int len, start, j, k;
  uint32_t t, zeta, zeta1, zeta2, t1, t2;
  uint8_t stage = 0;

  // Performing side channel resistant Inverse NTT structure with different twiddle factors...
  uint16_t random_twiddle_exponent[8]; //Generating random exponents for each stage...
  uint16_t sum_random_twiddle_exponent = 0;

  uint16_t index1, index2;

  // printf("Here...\n");
  for(int i=0;i<(NO_STAGES-1);i++)
  {
    // random_twiddle_exponent[i] = 0;
    // random_twiddle_exponent[i] = (get_random()+(256*get_random()))&((2*N)-1);
    // printf("%d, ",random_twiddle_exponent[i]);

    if(total_rand_bits_remaining <= 9)
    {
      spare_random = random_index_global;
      spare_random_length = total_rand_bits_remaining;

      #if(CALC_NTT_RAND_TIME_RAND == 1)
        t0_ntt = hal_get_time();
      #endif

      randombytes(random_buffer,RANDOM_BUFFER_SIZE);
      total_rand_bits_remaining = RANDOM_BUFFER_SIZE*8 + spare_random_length;

      random_index_global = (random_buffer[0]<<0) + (random_buffer[1]<<8) + (random_buffer[2]<<16)+ (random_buffer[3]<<24);

      #if(CALC_NTT_RAND_TIME_RAND == 1)
        t1_ntt = hal_get_time();
        randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;
      #endif
    }

    random_twiddle_exponent[i] = (spare_random + (random_index_global & ((1 << (9 - spare_random_length)) - 1)))&0x1FF;
    random_index_global = random_index_global >> (9-spare_random_length);
    total_rand_bits_remaining = total_rand_bits_remaining - (9 - spare_random_length);
    spare_random_length = 0;

    // random_twiddle_exponent[i] = random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining];
    // total_rand_bytes_remaining = total_rand_bytes_remaining-1;
    //
    // random_twiddle_exponent[i] = (random_twiddle_exponent[i] + random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining]) & ((2*N)-1);
    // total_rand_bytes_remaining = total_rand_bytes_remaining-1;

    sum_random_twiddle_exponent += random_twiddle_exponent[i];
  }

  random_twiddle_exponent[7] = ((2*N) - (sum_random_twiddle_exponent))&((2*N)-1);
  // printf("%d, ",random_twiddle_exponent[7]);
  // printf("\n");

  k = 1;
  for(len = 128; len > 0; len >>= 1)
  {
    for(start = 0; start < N; start = j + len)
    {
      index1 = (bitrev_order[k] + random_twiddle_exponent[stage])&((2*N)-1); // Correct...
      index2 = random_twiddle_exponent[stage];

      zeta1 = zetas_normal_order[index1];
      zeta2 = zetas_normal_order[index2];

      for(j = start; j < start + len; ++j)
      {
        t1 = montgomery_reduce((uint64_t)zeta1 * p[j + len]);
        t2 = montgomery_reduce((uint64_t)zeta2 * p[j]);
        p[j + len] = t2 + 2*Q - t1;
        p[j] = t2 + t1;
      }
      k = k+1;
    }
    stage = stage+1;
  }
}

#elif (NTT_PROTECTION_MODE == FINE_MULTIPLICATIVE_MASKING)

// Fine Multiplicative Masking...

void ntt(uint32_t p[N])
{
  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_ntt_time = 0;
  #endif

  unsigned int len, start, j, k;
  uint32_t t, zeta, zeta1, zeta2, zeta3, zeta4, t1, t2, t3, t4;
  uint8_t stage = 0;

  // Performing side channel resistant Inverse NTT structure with different twiddle factors...
  uint16_t random_twiddle_exponent[N]; //Generating random exponents for each stage...
  uint16_t sum_random_twiddle_exponent = 0;

  uint16_t index1, index2, index3, index4;
  uint16_t new_random_twiddle_index_1, new_random_twiddle_index_2;
  uint32_t combined_randomness;
  uint16_t ii1, ii2, ii3;

  // printf("Here...\n");
  for(int i=0;i<N;i++)
  {
    // // random_twiddle_exponent[i] = (get_random()+(256*get_random()))&((2*N)-1);
    //
    // if(total_rand_bytes_remaining < 2)
    // {
    //
    //   #if(CALC_NTT_RAND_TIME_RAND == 1)
    //     t0_ntt = hal_get_time();
    //   #endif
    //
    //   randombytes(random_buffer,RANDOM_BUFFER_SIZE);
    //   // prf(random_buffer, RANDOM_BUFFER_SIZE, seed, 0);
    //   total_rand_bytes_remaining = RANDOM_BUFFER_SIZE;
    //
    //   #if(CALC_NTT_RAND_TIME_RAND == 1)
    //
    //     t1_ntt = hal_get_time();
    //     randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;
    //
    //   #endif
    // }
    //
    //
    // random_twiddle_exponent[i] = random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining];
    // total_rand_bytes_remaining = total_rand_bytes_remaining-1;
    //
    // random_twiddle_exponent[i] = (random_twiddle_exponent[i] + random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining]) & ((2*N)-1);
    // total_rand_bytes_remaining = total_rand_bytes_remaining-1;
    //
    // p[i] = montgomery_reduce((uint64_t)p[i] * zetas_normal_order[random_twiddle_exponent[i]]);
    random_twiddle_exponent[i] = 0;

  }

  k = 1;
  for(len = 128; len > 0; len >>= 1)
  {
    for(start = 0; start < N; start = j + len)
    {
      ii3 = bitrev_order[k];
      for(j = start; j < start + len; ++j)
      {

        ii1 = 2*N - random_twiddle_exponent[j];
        ii2 = 2*N - random_twiddle_exponent[j+len];

        if(len == 1)
        {
          index1 = (ii1)&((2*N)-1); //A1
          index2 = (ii3 + ii2)&((2*N)-1); //B1
          index3 = (ii1)&((2*N)-1); //A2
          index4 = (ii3 + ii2)&((2*N)-1); //B2
        }
        else
        {
          // new_random_twiddle_index_1 = get_random()+(256*get_random());
          // new_random_twiddle_index_2 = get_random()+(256*get_random());

          // if(total_rand_bytes_remaining < 2)
          // {
          //
          //   #if(CALC_NTT_RAND_TIME_RAND == 1)
          //     t0_ntt = hal_get_time();
          //   #endif
          //
          //   randombytes(random_buffer,RANDOM_BUFFER_SIZE);
          //   // prf(random_buffer, RANDOM_BUFFER_SIZE, seed, 0);
          //   total_rand_bytes_remaining = RANDOM_BUFFER_SIZE;
          //
          //   #if(CALC_NTT_RAND_TIME_RAND == 1)
          //
          //     t1_ntt = hal_get_time();
          //     randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;
          //
          //   #endif
          // }
          //
          // new_random_twiddle_index_1 = random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining];
          // total_rand_bytes_remaining = total_rand_bytes_remaining-1;
          //
          // new_random_twiddle_index_1 = (new_random_twiddle_index_1 + random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining]);
          // total_rand_bytes_remaining = total_rand_bytes_remaining-1;


          // if(total_rand_bits_remaining <= 18)
          // {
          //   #if(CALC_NTT_RAND_TIME_RAND == 1)
          //     t0_ntt = hal_get_time();
          //   #endif
          //
          //   randombytes(random_buffer,RANDOM_BUFFER_SIZE);
          //   total_rand_bits_remaining = RANDOM_BUFFER_SIZE*8;
          //
          //   random_index_global = (random_buffer[0]<<0) + (random_buffer[1]<<8) + (random_buffer[2]<<16)+ (random_buffer[3]<<24);
          //
          //   #if(CALC_NTT_RAND_TIME_RAND == 1)
          //     t1_ntt = hal_get_time();
          //     randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;
          //   #endif
          // }
          //
          // new_random_twiddle_index_1 = (random_index_global & 0x1FF);
          // random_index_global = random_index_global >> 9;
          //
          // new_random_twiddle_index_2 = (random_index_global & 0x1FF);
          // random_index_global = random_index_global >> 9;
          //
          // total_rand_bits_remaining = total_rand_bits_remaining-18;

          if(total_rand_bits_remaining <= 18)
          {
            spare_random = random_index_global;
            spare_random_length = total_rand_bits_remaining;

            #if(CALC_NTT_RAND_TIME_RAND == 1)
              t0_ntt = hal_get_time();
            #endif

            randombytes(random_buffer,RANDOM_BUFFER_SIZE);
            total_rand_bits_remaining = RANDOM_BUFFER_SIZE*8 + spare_random_length;

            random_index_global = (random_buffer[0]<<0) + (random_buffer[1]<<8) + (random_buffer[2]<<16)+ (random_buffer[3]<<24);

            #if(CALC_NTT_RAND_TIME_RAND == 1)
              t1_ntt = hal_get_time();
              randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;
            #endif
          }

          combined_randomness = spare_random + (random_index_global & ((1 << (18 - spare_random_length)) - 1));
          random_index_global = random_index_global >> (18-spare_random_length);
          total_rand_bits_remaining = total_rand_bits_remaining - (18 - spare_random_length);
          spare_random_length = 0;

          new_random_twiddle_index_1 = (combined_randomness >> 9) & 0x1FF;
          new_random_twiddle_index_2 = combined_randomness & 0x1FF;

          // if(total_rand_bytes_remaining < 2)
          // {
          //
          //   #if(CALC_NTT_RAND_TIME_RAND == 1)
          //     t0_ntt = hal_get_time();
          //   #endif
          //
          //   randombytes(random_buffer,RANDOM_BUFFER_SIZE);
          //   // prf(random_buffer, RANDOM_BUFFER_SIZE, seed, 0);
          //   total_rand_bytes_remaining = RANDOM_BUFFER_SIZE;
          //
          //   #if(CALC_NTT_RAND_TIME_RAND == 1)
          //
          //     t1_ntt = hal_get_time();
          //     randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;
          //
          //   #endif
          // }
          //
          // new_random_twiddle_index_2 = random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining];
          // total_rand_bytes_remaining = total_rand_bytes_remaining-1;
          //
          // new_random_twiddle_index_2 = (new_random_twiddle_index_2 + random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining]);
          // total_rand_bytes_remaining = total_rand_bytes_remaining-1;

          index1 = (ii1 + new_random_twiddle_index_1)&((2*N)-1); //A1
          index2 = (ii3 + ii2 + new_random_twiddle_index_1)&((2*N)-1); //B1
          index3 = (ii1 + new_random_twiddle_index_2)&((2*N)-1); //A2
          index4 = (ii3 + ii2 + new_random_twiddle_index_2)&((2*N)-1); //B2
        }

        random_twiddle_exponent[j] = new_random_twiddle_index_1;
        random_twiddle_exponent[j+len] = new_random_twiddle_index_2;

        zeta1 = zetas_normal_order[index1];
        zeta2 = zetas_normal_order[index2];
        zeta3 = zetas_normal_order[index3];
        zeta4 = zetas_normal_order[index4];

        t1 = montgomery_reduce((uint64_t) zeta1 * p[j]);
        t2 = montgomery_reduce((uint64_t) zeta2 * p[j+len]);
        t3 = montgomery_reduce((uint64_t) zeta3 * p[j]);
        t4 = montgomery_reduce((uint64_t) zeta4 * p[j + len]);

        p[j + len] = t3 + 2*Q - t4;
        p[j] = t1 + t2;

      }
      k = k+1;
    }
    stage = stage+1;
  }
}

#elif (NTT_PROTECTION_MODE == GENERIC_MULTIPLICATIVE_MASKING)

void ntt(uint32_t p[N])
{

  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_ntt_time = 0;
  #endif

  unsigned int len, start, j, k, k_prev;
  uint32_t t, zeta, zeta1, zeta2, zeta3, zeta4, t1, t2, t3, t4;
  uint8_t stage = 0;

  // Performing side channel resistant Inverse NTT structure with different twiddle factors...
  uint16_t random_twiddle_exponent[N]; //Generating random exponents for each stage...
  uint16_t sum_random_twiddle_exponent = 0;

  uint8_t new_random_twiddle_exponent[2*N];

  // No of masks:

  // uint8_t no_masks_per_stage_shift = get_random()%9;
  uint8_t no_masks_per_stage_shift = NO_MASKS_IN_STAGE;

  int no_masks_per_stage = (1 << no_masks_per_stage_shift);

  // Lets just ignore the first stage masking for now, as it might add some un-necessary overhead...

  unsigned int max_length_of_group = (N)/(no_masks_per_stage);
  uint8_t max_length_of_group_shift = 8 - no_masks_per_stage_shift;

  // SISO, if 2*len <= max_length_of_group...
  // SIDO if 1st stage and no_masks > 1...
  // DIDO if 2*len > max_length_of_group...

  uint16_t mask_refresh_no = 0;
  uint16_t mask_no = 0;
  uint16_t mask_j_exponent, mask_j_len_exponent;
  uint16_t mask_j_exponent_prev, mask_j_len_exponent_prev;

  mask_j_exponent = 0x00;
  mask_j_len_exponent = 0x00;
  mask_j_exponent_prev = 0xFF;
  mask_j_len_exponent_prev = 0xFF;

  uint16_t index1, index2, index3, index4;
  uint16_t new_random_twiddle_index_1, new_random_twiddle_index_2, random_index;
  uint16_t ii1, ii2, ii3;

  // printf("Here...\n");
  for(int i=0;i<N;i++)
  {
    // random_twiddle_exponent[i] = (get_random()+(256*get_random()))&((2*N)-1);
    random_twiddle_exponent[i] = 0;
    // p[i] = montgomery_reduce((uint64_t)p[i] * zetas_normal_order[random_twiddle_exponent[i]]);
  }

  k = 1;
  k_prev = 2;

  for(len = 128; len > 0; len >>= 1)
  {
    for(int i=0;i<no_masks_per_stage;i++)
    {
      if(len > 2)
      {
        // random_index = (get_random()*256)+get_random();

        // if(total_rand_bytes_remaining < 2)
        // {
        //
        //   #if(CALC_NTT_RAND_TIME_RAND == 1)
        //     t0_ntt = hal_get_time();
        //   #endif
        //
        //   randombytes(random_buffer,RANDOM_BUFFER_SIZE);
        //   // prf(random_buffer, RANDOM_BUFFER_SIZE, seed, 0);
        //   total_rand_bytes_remaining = RANDOM_BUFFER_SIZE;
        //
        //   #if(CALC_NTT_RAND_TIME_RAND == 1)
        //
        //     t1_ntt = hal_get_time();
        //     randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;
        //
        //   #endif
        // }
        //
        // random_index = random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining];
        // total_rand_bytes_remaining = total_rand_bytes_remaining-1;
        //
        // random_index = (random_index + random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining]);
        // total_rand_bytes_remaining = total_rand_bytes_remaining-1;


        if(total_rand_bits_remaining <= 9)
        {
          spare_random = random_index_global;
          spare_random_length = total_rand_bits_remaining;

          #if(CALC_NTT_RAND_TIME_RAND == 1)
            t0_ntt = hal_get_time();
          #endif

          randombytes(random_buffer,RANDOM_BUFFER_SIZE);
          total_rand_bits_remaining = RANDOM_BUFFER_SIZE*8 + spare_random_length;

          random_index_global = (random_buffer[0]<<0) + (random_buffer[1]<<8) + (random_buffer[2]<<16)+ (random_buffer[3]<<24);

          #if(CALC_NTT_RAND_TIME_RAND == 1)
            t1_ntt = hal_get_time();
            randomize_ntt_time = randomize_ntt_time + t1_ntt - t0_ntt;
          #endif
        }

        random_index = spare_random + (random_index_global & ((1 << (9 - spare_random_length)) - 1));
        random_index_global = random_index_global >> (9-spare_random_length);
        total_rand_bits_remaining = total_rand_bits_remaining - (9 - spare_random_length);
        spare_random_length = 0;

        new_random_twiddle_exponent[i] = (random_index)&((2*N)-1);
      }
      else
      {
        new_random_twiddle_exponent[i] = (2*N - random_twiddle_exponent[i])&((2*N)-1);
      }
    }

    if((2*len) > max_length_of_group) // DIDO...
    {

      // printf("DIDO\n");
      for(start = 0; start < 256; start = j + len)
      {
        ii3 = bitrev_order[k];
        for(j = start; j < start + len; ++j)
        {

          mask_j_exponent = j >> (max_length_of_group_shift);
          mask_j_len_exponent = (j+len) >> (max_length_of_group_shift);

          ii1 = 2*N - random_twiddle_exponent[mask_j_exponent];
          ii2 = 2*N - random_twiddle_exponent[mask_j_len_exponent];

          if((mask_j_exponent_prev != mask_j_exponent) || (k_prev != k))
          {

            k_prev = k;
            mask_j_exponent_prev = mask_j_exponent;
            mask_j_len_exponent_prev = mask_j_len_exponent;

            if(len == 1)
            {
              index1 = (ii1)&((2*N)-1); //A1
              index2 = (ii3 + ii2)&((2*N)-1); //B1

              zeta1 = zetas_normal_order[index1];
              zeta2 = zetas_normal_order[index2];

            }
            else
            {
              // new_random_twiddle_index_1 = get_random()+(256*get_random());
              // new_random_twiddle_index_2 = get_random()+(256*get_random());

              index1 = (ii1 + new_random_twiddle_exponent[mask_j_exponent])&((2*N)-1); //A1
              index2 = (ii3 + ii2 + new_random_twiddle_exponent[mask_j_exponent])&((2*N)-1); //B1
              index3 = (ii1 + new_random_twiddle_exponent[mask_j_len_exponent])&((2*N)-1); //A2
              index4 = (ii3 + ii2 + new_random_twiddle_exponent[mask_j_len_exponent])&((2*N)-1); //B2

              zeta1 = zetas_normal_order[index1];
              zeta2 = zetas_normal_order[index2];
              zeta3 = zetas_normal_order[index3];
              zeta4 = zetas_normal_order[index4];
            }
          }


          if(len == 1)
          {
            t1 = montgomery_reduce((uint64_t)zeta2 * p[j + len]);
            t2 = montgomery_reduce((uint64_t)zeta1 * p[j]);
            p[j + len] = t2 + 2*Q - t1;
            p[j] = t2 + t1;
          }
          else
          {
            t1 = montgomery_reduce((uint64_t) zeta1 * p[j]);
            t2 = montgomery_reduce((uint64_t) zeta2 * p[j+len]);
            t3 = montgomery_reduce((uint64_t) zeta3 * p[j]);
            t4 = montgomery_reduce((uint64_t) zeta4 * p[j + len]);

            p[j + len] = t3 + 2*Q - t4;
            p[j] = t1 + t2;
          }

        }
        k = k+1;
      }
      for(int i=0;i<no_masks_per_stage;i++)
      {
          random_twiddle_exponent[i] = new_random_twiddle_exponent[i];
      }
    }


    else if((2*len) <= max_length_of_group)
    {
      // printf("SISO\n");
      for(start = 0; start < 256; start = j + len)
      {
        ii3 = bitrev_order[k];

        for(j = start; j < start + len; ++j)
        {
          mask_j_exponent = j >> (max_length_of_group_shift);

          ii1 = 2*N - random_twiddle_exponent[mask_j_exponent];

          if((mask_j_exponent_prev != mask_j_exponent) || (k_prev != k))
          {

            k_prev = k;
            mask_j_exponent_prev = mask_j_exponent;

            if(len == 1)
            {
              index1 = (ii1)&((2*N)-1); //A1
              index2 = (ii3 + ii1)&((2*N)-1); //B1

              zeta1 = zetas_normal_order[index1];
              zeta2 = zetas_normal_order[index2];
            }
            else
            {
              index1 = (ii1 + new_random_twiddle_exponent[mask_j_exponent])&((2*N)-1); //A1
              index2 = (ii3 + ii1 + new_random_twiddle_exponent[mask_j_exponent])&((2*N)-1); //B1

              zeta1 = zetas_normal_order[index1];
              zeta2 = zetas_normal_order[index2];
            }
          }

          t1 = montgomery_reduce((uint64_t)zeta2 * p[j + len]);
          t2 = montgomery_reduce((uint64_t)zeta1 * p[j]);
          p[j + len] = t2 + 2*Q - t1;
          p[j] = t2 + t1;
        }
        k = k+1;
      }
      for(int i=0;i<no_masks_per_stage;i++)
      {
          random_twiddle_exponent[i] = new_random_twiddle_exponent[i];
      }
    }
  }
}



#endif

/*************************************************
* Name:        invntt_tomont
*
* Description: Inverse NTT and multiplication by Montgomery factor 2^32.
*              In-place. No modular reductions after additions or
*              subtractions. Input coefficient need to be smaller than 2*Q.
*              Output coefficient are smaller than 2*Q.
*
* Arguments:   - uint32_t p[N]: input/output coefficient array
**************************************************/

void invntt_tomont_no_protect(uint32_t p[N])
{
  // #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
  //   randomize_intt_time = 0;
  // #endif

  unsigned int start, len, j, k;
  uint32_t t, zeta;
  const uint32_t f = (((uint64_t)MONT*MONT % Q) * (Q-1) % Q) * ((Q-1) >> 8) % Q;

  k = 0;
  // printf("K...\n");
  for(len = 1; len < N; len <<= 1)
  {
    for(start = 0; start < N; start = j + len)
    {
      zeta = zetas_inv[k++];
      for(j = start; j < start + len; ++j)
      {
        // printf("%d, ",(k-1));
        t = p[j];
        p[j] = t + p[j + len];
        p[j + len] = t + 256*Q - p[j + len];
        p[j + len] = montgomery_reduce((uint64_t)zeta * p[j + len]);
      }
    }
    // printf("\n SPACE \n");
  }

  for(j = 0; j < N; ++j)
  {
    p[j] = montgomery_reduce((uint64_t)f * p[j]);
  }
}

#if (NTT_PROTECTION_MODE == NO_PROTECTION)

void invntt_tomont(uint32_t p[N])
{
  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_intt_time = 0;
  #endif

  unsigned int start, len, j, k;
  uint32_t t, zeta;
  const uint32_t f = (((uint64_t)MONT*MONT % Q) * (Q-1) % Q) * ((Q-1) >> 8) % Q;

  k = 0;
  // printf("K...\n");
  for(len = 1; len < N; len <<= 1)
  {
    for(start = 0; start < N; start = j + len)
    {
      zeta = zetas_inv[k++];
      for(j = start; j < start + len; ++j)
      {
        // printf("%d, ",(k-1));
        t = p[j];
        p[j] = t + p[j + len];
        p[j + len] = t + 256*Q - p[j + len];
        p[j + len] = montgomery_reduce((uint64_t)zeta * p[j + len]);
      }
    }
    // printf("\n SPACE \n");
  }

  for(j = 0; j < N; ++j)
  {
    p[j] = montgomery_reduce((uint64_t)f * p[j]);
  }
}

#elif (NTT_PROTECTION_MODE == GROUP_COARSE_SHUFFLING)

// Coarse shuffling within groups...

void invntt_tomont(uint32_t p[N])
{
  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_intt_time = 0;
  #endif

  unsigned int start, len, j, k, start1;
  uint32_t t, zeta;
  uint8_t len1, temp;
  const uint32_t f = (((uint64_t)MONT*MONT % Q) * (Q-1) % Q) * ((Q-1) >> 8) % Q;

  uint8_t stage = 0;
  k = 128;
  for(len = 0; len < 8; len++)
  {
    len1 = 1 << (len);
    if(len > 0)
    {
        for(start = 0; start < N; start = j + len1)
        {
          zeta = zetas_inv[k++];

          #if(CALC_NTT_RAND_TIME == 1)
            t0_intt = hal_get_time();
          #endif

          randomize_i(&(multi_ordered_array[len][0]), len1);

          #if(CALC_NTT_RAND_TIME == 1)
            t1_intt = hal_get_time();
            randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;
          #endif

          for(j = start; j < start + len1; ++j)
          {
            temp = multi_ordered_array[len][j-start] + start;

            t = p[temp];
            p[temp] = t + p[temp + len1];
            p[temp + len1] = t + 256*Q - p[temp + len1];
            p[temp + len1] = montgomery_reduce((uint64_t)zeta * p[temp + len1]);
          }
        }
    }
    else
    {
      #if(CALC_NTT_RAND_TIME == 1)
        t0_intt = hal_get_time();
      #endif

      randomize_i(&(multi_ordered_array[7][0]), 128);

      #if(CALC_NTT_RAND_TIME == 1)
        t1_intt = hal_get_time();
        randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;
      #endif

      for(start1 = 0; start1 < 128; start1++)
      {
        temp = multi_ordered_array[7][start1];
        zeta = zetas_inv[inverse_twiddle_factor_index_array[stage][temp]];
        temp = inverse_index_array[stage][temp];

        t = p[temp];
        p[temp] = t + p[temp + len1];
        p[temp + len1] = t + 256*Q - p[temp + len1];
        p[temp + len1] = montgomery_reduce((uint64_t)zeta * p[temp + len1]);
      }
    }
    stage = stage+1;
  }

  for(j = 0; j < N; ++j)
  {
    p[j] = montgomery_reduce((uint64_t)f * p[j]);
  }
}

#elif (NTT_PROTECTION_MODE == COARSE_SHUFFLING)

// Coarse Shuffling...

void invntt_tomont(uint32_t p[N]) {

  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_intt_time = 0;
  #endif

  unsigned int start, len, j, k;
  uint32_t t, zeta;
  uint8_t stage = 0;
  const uint32_t f = (((uint64_t)MONT*MONT % Q) * (Q-1) % Q) * ((Q-1) >> 8) % Q;
  uint8_t temp;

  k = 0;
  for(len = 1; len < N; len <<= 1)
  {
    #if(CALC_NTT_RAND_TIME == 1)
      t0_intt = hal_get_time();
    #endif

    randomize_i(&(multi_ordered_array[7][0]), 128);

    #if(CALC_NTT_RAND_TIME == 1)
      t1_intt = hal_get_time();
      randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;
    #endif

    for(start = 0; start < 128; start++)
    {
      temp = multi_ordered_array[7][start];
      zeta = zetas_inv[inverse_twiddle_factor_index_array[stage][temp]];
      temp = inverse_index_array[stage][temp];

      t = p[temp];
      p[temp] = t + p[temp + len];
      p[temp + len] = t + 256*Q - p[temp + len];
      p[temp + len] = montgomery_reduce((uint64_t)zeta * p[temp + len]);

    }
    stage = stage+1;
  }

  for(j = 0; j < N; ++j)
  {
    p[j] = montgomery_reduce((uint64_t)f * p[j]);
  }
}

#elif (NTT_PROTECTION_MODE == GROUP_SHUFFLING)

void invntt_tomont(uint32_t p[N])
{
  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_intt_time = 0;
  #endif

  unsigned int start, len, j, k, g;
  uint32_t t, zeta;
  const uint32_t f = (((uint64_t)MONT*MONT % Q) * (Q-1) % Q) * ((Q-1) >> 8) % Q;
  uint8_t len1,temp,no_groups,row_no,stage;
  stage = 0;
  k = 0;
  for(len = 0; len < 8; len++)
  {
    len1 = (1 << len);
    no_groups = 128/len1;
    row_no = 7-len;
    if(no_groups > 1)
    {
      #if(CALC_NTT_RAND_TIME == 1)
        t0_intt = hal_get_time();
      #endif

      randomize_i(&(multi_ordered_array[row_no][0]), no_groups);

      #if(CALC_NTT_RAND_TIME == 1)
        t1_intt = hal_get_time();
        randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;
      #endif

      for(g = 0; g < no_groups; g++)
      {
        start = (multi_ordered_array[row_no][g])*2*len1;
        zeta = zetas_inv[inverse_twiddle_factor_index_array[stage][start/2]];

        for(j = start; j < start + len1; ++j)
        {
          t = p[j];
          p[j] = t + p[j + len1];
          p[j + len1] = t + 256*Q - p[j + len1];
          p[j + len1] = montgomery_reduce((uint64_t)zeta * p[j + len1]);
        }
      }
    }
    else
    {
      #if(CALC_NTT_RAND_TIME == 1)
        t0_intt = hal_get_time();
      #endif

      randomize_i(&(multi_ordered_array[7][0]), 128);

      #if(CALC_NTT_RAND_TIME == 1)
        t1_intt = hal_get_time();
        randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;
      #endif

      for(start = 0; start < 128; start++)
      {
        temp = multi_ordered_array[7][start];
        zeta = zetas_inv[inverse_twiddle_factor_index_array[stage][temp]];
        temp = inverse_index_array[stage][temp];

        t = p[temp];
        p[temp] = t + p[temp + len1];
        p[temp + len1] = t + 256*Q - p[temp + len1];
        p[temp + len1] = montgomery_reduce((uint64_t)zeta * p[temp + len1]);

      }
    }
    stage = stage+1;
  }

  for(j = 0; j < N; ++j)
  {
    p[j] = montgomery_reduce((uint64_t)f * p[j]);
  }
}

#elif (NTT_PROTECTION_MODE == FINE_SHUFFLING)

// Fine Shuffling...

void invntt_tomont(uint32_t p[N])
{
  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_intt_time = 0;
  #endif

  unsigned int start, len, j, k;
  uint32_t zeta, temp, op1, op2, out1, out2, temp_new;
  uint8_t randi, bitrand;
  int16_t mask;

  total_rand_bytes_remaining = 0;
  int count = 32;

  uint32_t op1_new, op2_new;
  uint8_t op1_new_bit, op2_new_bit, bit;

  const uint32_t f = (((uint64_t)MONT*MONT % Q) * (Q-1) % Q) * ((Q-1) >> 8) % Q;

  k = 0;
  for(len = 1; len < N; len <<= 1)
  {
    for(start = 0; start < N; start = j + len)
    {
      zeta = zetas_inv[k++];
      for(j = start; j < start + len; ++j)
      {
        // if((count&0x7) == 0)
        // {
        //   randi = get_random();
        // }

        if(count == 32)
        {

          #if(CALC_NTT_RAND_TIME_RAND == 1)
            t0_intt = hal_get_time();
          #endif

          randombytes(random_buffer,RANDOM_BUFFER_SIZE);
          // prf(random_buffer, RANDOM_BUFFER_SIZE, seed, 0);
          total_rand_bytes_remaining = RANDOM_BUFFER_SIZE;

          #if(CALC_NTT_RAND_TIME_RAND == 1)

            t1_intt = hal_get_time();
            randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;

          #endif

          count = 0;
        }

        randi = random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining];
        if(count > 0 && (count & 0xFF) == 0)
          total_rand_bytes_remaining = total_rand_bytes_remaining-1;

        // mask = -1*(bitrand);
        bitrand = (randi>>(count&0x7))&0x1;

        op1 = p[j+bitrand*len];
        op2 = p[j+(1-bitrand)*len];

        #if(CALC_NTT_RAND_TIME == 1)
          t0_intt = hal_get_time();
        #endif

        // temp = (op1 ^ op2)&mask;
        // op1 = op1 ^ temp;
        // op2 = op2 ^ temp;

        count = count+1;
        temp = (op1 ^ op2);

        // op1_new = 0;
        // op2_new = 0;
        //
        // for(int cc = 0; cc < 32; cc++)
        // {
        //   bit = ((temp >> cc) & 1) & bitrand;
        //   op1_new_bit = ((op1 >> cc) & 1) ^ bit;
        //   op2_new_bit = ((op2 >> cc) & 1) ^ bit;
        //   op1_new |= (op1_new_bit << cc);
        //   op2_new |= (op2_new_bit << cc);
        // }
        //
        // op1 = op1_new;
        // op2 = op2_new;

        temp_new = 0;

        for(int cc = 0; cc < 32; cc++)
        {
          bit = ((temp >> cc)) & bitrand;
          temp_new |= (bit << cc);
        }

        op1 = op1 ^ temp_new;
        op2 = op2 ^ temp_new;


        #if(CALC_NTT_RAND_TIME == 1)
          t1_intt = hal_get_time();
          randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;
        #endif

        out1 = op1 + op2;
        op2 = op1 + 256*Q - op2;
        out2 = montgomery_reduce((uint64_t)zeta * op2);

        if(count == 32)
        {

          #if(CALC_NTT_RAND_TIME_RAND == 1)
            t0_intt = hal_get_time();
          #endif

          randombytes(random_buffer,RANDOM_BUFFER_SIZE);
          // prf(random_buffer, RANDOM_BUFFER_SIZE, seed, 0);
          total_rand_bytes_remaining = RANDOM_BUFFER_SIZE;

          #if(CALC_NTT_RAND_TIME_RAND == 1)

            t1_intt = hal_get_time();
            randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;

          #endif

          count = 0;
        }

        randi = random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining];

        if(count > 0 && (count & 0xFF) == 0)
          total_rand_bytes_remaining = total_rand_bytes_remaining-1;

        #if(CALC_NTT_RAND_TIME == 1)
        t0_intt = hal_get_time();
        #endif

        bitrand = randi>>(count&0x7)&0x1;
        // mask = -1*(bitrand);
        count = count+1;

        // temp = (out1 ^ out2)&mask;
        // out1 = out1 ^ temp;
        // out2 = out2 ^ temp;

        // op1_new = 0;
        // op2_new = 0;

        temp = (out1 ^ out2);

        // for(int cc = 0; cc < 32; cc++)
        // {
        //   bit = ((temp >> cc) & 1) & bitrand;
        //   op1_new_bit = ((out1 >> cc) & 1) ^ bit;
        //   op2_new_bit = ((out2 >> cc) & 1) ^ bit;
        //   op1_new |= (op1_new_bit << cc);
        //   op2_new |= (op2_new_bit << cc);
        // }
        //
        // out1 = op1_new;
        // out2 = op2_new;

        temp_new = 0;

        for(int cc = 0; cc < 32; cc++)
        {
          bit = ((temp >> cc)) & bitrand;
          temp_new |= (bit << cc);
        }

        out1 = out1 ^ temp_new;
        out2 = out2 ^ temp_new;

        #if(CALC_NTT_RAND_TIME == 1)
        t1_intt = hal_get_time();
        randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;
        #endif

        p[j+(bitrand)*len] = out1;
        p[j+(1-bitrand)*len] = out2;

      }
    }
  }

  for(j = 0; j < N; ++j) {
    p[j] = montgomery_reduce((uint64_t)f * p[j]);
  }
}

#elif (NTT_PROTECTION_MODE == COARSE_MULTIPLICATIVE_MASKING)

// Coarse multiplicative masking...

void invntt_tomont(uint32_t p[N])
{
  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_intt_time = 0;
  #endif

  unsigned int start, len, j, k;
  uint32_t t, zeta1, zeta2;
  uint16_t random_index;
  uint8_t stage = 0;

  const uint32_t f = (((uint64_t)MONT*MONT % Q) * (Q-1) % Q) * ((Q-1) >> 8) % Q;

  // Performing side channel resistant Inverse NTT structure with different twiddle factors...
  uint16_t random_twiddle_exponent[8]; //Generating random exponents for each stage...
  uint16_t sum_random_twiddle_exponent = 0;

  uint16_t index1, index2;

  for(int i=0;i<(NO_STAGES-1);i++)
  {
    // random_twiddle_exponent[i] = 0;
    // random_twiddle_exponent[i] = (get_random()+(256*get_random()))&((2*N)-1);

    // if(total_rand_bytes_remaining < 2)
    // {
    //
    //   #if(CALC_NTT_RAND_TIME_RAND == 1)
    //     t0_intt = hal_get_time();
    //   #endif
    //
    //   // randombytes(random_buffer,RANDOM_BUFFER_SIZE);
    //   // // prf(random_buffer, RANDOM_BUFFER_SIZE, seed, 0);
    //   // total_rand_bytes_remaining = RANDOM_BUFFER_SIZE;
    //
    //   #if(CALC_NTT_RAND_TIME_RAND == 1)
    //
    //     t1_intt = hal_get_time();
    //     randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;
    //
    //   #endif
    // }

    if(total_rand_bits_remaining <= 9)
    {
      spare_random = random_index_global;
      spare_random_length = total_rand_bits_remaining;

      #if(CALC_NTT_RAND_TIME_RAND == 1)
        t0_intt = hal_get_time();
      #endif

      randombytes(random_buffer,RANDOM_BUFFER_SIZE);
      total_rand_bits_remaining = RANDOM_BUFFER_SIZE*8 + spare_random_length;

      random_index_global = (random_buffer[0]<<0) + (random_buffer[1]<<8) + (random_buffer[2]<<16)+ (random_buffer[3]<<24);

      #if(CALC_NTT_RAND_TIME_RAND == 1)
        t1_intt = hal_get_time();
        randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;
      #endif
    }

    random_twiddle_exponent[i] = (spare_random + (random_index_global & ((1 << (9 - spare_random_length)) - 1)))&0x1FF;
    random_index_global = random_index_global >> (9-spare_random_length);
    total_rand_bits_remaining = total_rand_bits_remaining - (9 - spare_random_length);
    spare_random_length = 0;

    // random_twiddle_exponent[i] = random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining];
    // total_rand_bytes_remaining = total_rand_bytes_remaining-1;
    //
    // random_twiddle_exponent[i] = (random_twiddle_exponent[i] + random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining]) & ((2*N)-1);
    // total_rand_bytes_remaining = total_rand_bytes_remaining-1;

    sum_random_twiddle_exponent += random_twiddle_exponent[i];
  }

  random_twiddle_exponent[7] = ((2*N) - (sum_random_twiddle_exponent))&((2*N)-1);

  // k = 0;
  // for(len = 1; len < N; len <<= 1)
  // {
  //   for(start = 0; start < N; start = j + len)
  //   {
  //     // zeta = zetas_inv[k++];
  //
  //     index1 = (inverse_zeta_order[k] + random_twiddle_exponent[stage])&((2*N)-1);
  //     index2 = random_twiddle_exponent[stage];
  //
  //     zeta1 = zetas_normal_order[index1];
  //     // printf("%d, ",zeta1);
  //     zeta2 = zetas_normal_order[index2];
  //
  //     for(j = start; j < start + len; ++j)
  //     {
  //       t = p[j];
  //       p[j] = montgomery_reduce((uint64_t)zeta2 * (t + p[j + len]));
  //       p[j + len] = t + 256*Q - p[j + len];
  //       p[j + len] = montgomery_reduce((uint64_t)zeta1 * p[j + len]);
  //     }
  //
  //     k = k+1;
  //   }
  //   stage = stage+1;
  // }


  k = 0;
  for(len = 1; len < N; len <<= 1)
  {
    for(start = 0; start < N; start = j + len)
    {
      // zeta = zetas_inv[k++];

      index1 = (inverse_zeta_order[k] + random_twiddle_exponent[stage])&((2*N)-1);
      index2 = random_twiddle_exponent[stage];

      zeta1 = zetas_normal_order[index1];
      // printf("%d, ",zeta1);
      zeta2 = zetas_normal_order[index2];

      for(j = start; j < start + len; ++j)
      {
        t = p[j];
        p[j] = montgomery_reduce((uint64_t)zeta2 * (t + p[j + len]));
        p[j + len] = t + 256*Q - p[j + len];
        p[j + len] = montgomery_reduce((uint64_t)zeta1 * p[j + len]);
      }

      k = k+1;
    }
    stage = stage+1;
  }

  for(j = 0; j < N; ++j)
  {
    p[j] = montgomery_reduce((uint64_t)f * p[j]);
  }
}

#elif (NTT_PROTECTION_MODE == FINE_MULTIPLICATIVE_MASKING)

// Fine multiplicative masking...

void invntt_tomont(uint32_t p[N])
{
  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_intt_time = 0;
  #endif

  unsigned int start, len, j, k;
  uint32_t t, zeta, zeta1, zeta2, zeta3, zeta4, t1, t2, t3, t4;
  uint16_t index1, index2, index3, index4, new_random_twiddle_index_1, new_random_twiddle_index_2;
  uint8_t stage = 0;

  const uint32_t f = (((uint64_t)MONT*MONT % Q) * (Q-1) % Q) * ((Q-1) >> 8) % Q;

  // Performing side channel resistant Inverse NTT structure with different twiddle factors...
  uint16_t random_twiddle_exponent[N]; //Generating random exponents for each stage...
  uint16_t sum_random_twiddle_exponent = 0;
  uint16_t ii1, ii2, ii3;
  uint32_t combined_randomness;

  for(int i=0;i<N;i++)
  {
    // random_twiddle_exponent[i] = (get_random()+(256*get_random()))&((2*N)-1);

    // if(total_rand_bytes_remaining < 2)
    // {
    //
    //   #if(CALC_NTT_RAND_TIME_RAND == 1)
    //     t0_intt = hal_get_time();
    //   #endif
    //
    //   randombytes(random_buffer,RANDOM_BUFFER_SIZE);
    //   // prf(random_buffer, RANDOM_BUFFER_SIZE, seed, 0);
    //   total_rand_bytes_remaining = RANDOM_BUFFER_SIZE;
    //
    //   #if(CALC_NTT_RAND_TIME_RAND == 1)
    //
    //     t1_intt = hal_get_time();
    //     randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;
    //
    //   #endif
    // }
    //
    // random_twiddle_exponent[i] = random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining];
    // total_rand_bytes_remaining = total_rand_bytes_remaining-1;
    //
    // random_twiddle_exponent[i] = (random_twiddle_exponent[i] + random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining]) & ((2*N)-1);
    // total_rand_bytes_remaining = total_rand_bytes_remaining-1;

    random_twiddle_exponent[i] = 0;
    // p[i] = montgomery_reduce((uint64_t)p[i] * zetas_normal_order[random_twiddle_exponent[i]]);
  }

  k = 0;
  for(len = 1; len < N; len <<= 1)
  {
    for(start = 0; start < N; start = j + len)
    {
      ii3 = inverse_zeta_order[k];
      for(j = start; j < start + len; ++j)
      {

        ii1 = 2*N - random_twiddle_exponent[j];
        ii2 = 2*N - random_twiddle_exponent[j+len];

        if(len == N/2)
        {
          index1 = (ii1)&((2*N)-1); //A1
          index2 = (ii2)&((2*N)-1); // B1
          index3 = (ii3 + ii1)&((2*N)-1); //A2
          index4 = (ii3 + ii2)&((2*N)-1); //B2
        }
        else
        {

          // if(total_rand_bytes_remaining < 2)
          // {
          //
          //   #if(CALC_NTT_RAND_TIME_RAND == 1)
          //     t0_intt = hal_get_time();
          //   #endif
          //
          //   randombytes(random_buffer,RANDOM_BUFFER_SIZE);
          //   // prf(random_buffer, RANDOM_BUFFER_SIZE, seed, 0);
          //   total_rand_bytes_remaining = RANDOM_BUFFER_SIZE;
          //
          //   #if(CALC_NTT_RAND_TIME_RAND == 1)
          //
          //     t1_intt = hal_get_time();
          //     randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;
          //
          //   #endif
          // }
          //
          // new_random_twiddle_index_1 = random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining];
          // total_rand_bytes_remaining = total_rand_bytes_remaining-1;
          //
          // new_random_twiddle_index_1 = (new_random_twiddle_index_1 + random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining]);
          // total_rand_bytes_remaining = total_rand_bytes_remaining-1;
          //
          //
          // if(total_rand_bytes_remaining < 2)
          // {
          //
          //   #if(CALC_NTT_RAND_TIME_RAND == 1)
          //     t0_intt = hal_get_time();
          //   #endif
          //
          //   randombytes(random_buffer,RANDOM_BUFFER_SIZE);
          //   // prf(random_buffer, RANDOM_BUFFER_SIZE, seed, 0);
          //   total_rand_bytes_remaining = RANDOM_BUFFER_SIZE;
          //
          //   #if(CALC_NTT_RAND_TIME_RAND == 1)
          //
          //     t1_intt = hal_get_time();
          //     randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;
          //
          //   #endif
          // }
          //
          // new_random_twiddle_index_2 = random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining];
          // total_rand_bytes_remaining = total_rand_bytes_remaining-1;
          //
          // new_random_twiddle_index_2 = (new_random_twiddle_index_2 + random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining]);
          // total_rand_bytes_remaining = total_rand_bytes_remaining-1;


          if(total_rand_bits_remaining <= 18)
          {
            spare_random = random_index_global;
            spare_random_length = total_rand_bits_remaining;

            #if(CALC_NTT_RAND_TIME_RAND == 1)
              t0_intt = hal_get_time();
            #endif

            randombytes(random_buffer,RANDOM_BUFFER_SIZE);
            total_rand_bits_remaining = RANDOM_BUFFER_SIZE*8 + spare_random_length;

            random_index_global = (random_buffer[0]<<0) + (random_buffer[1]<<8) + (random_buffer[2]<<16)+ (random_buffer[3]<<24);

            #if(CALC_NTT_RAND_TIME_RAND == 1)
              t1_intt = hal_get_time();
              randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;
            #endif
          }

          combined_randomness = spare_random + (random_index_global & ((1 << (18 - spare_random_length)) - 1));
          random_index_global = random_index_global >> (18-spare_random_length);
          total_rand_bits_remaining = total_rand_bits_remaining - (18 - spare_random_length);
          spare_random_length = 0;

          new_random_twiddle_index_1 = (combined_randomness >> 9) & 0x1FF;
          new_random_twiddle_index_2 = combined_randomness & 0x1FF;

          index1 = (ii1 + new_random_twiddle_index_1)&((2*N)-1); //A1
          index2 = (ii2 + new_random_twiddle_index_1)&((2*N)-1); // B1
          index3 = (ii3 + ii1 + new_random_twiddle_index_2)&((2*N)-1); //A2
          index4 = (ii3 + ii2 + new_random_twiddle_index_2)&((2*N)-1); //B2
        }

        random_twiddle_exponent[j] = new_random_twiddle_index_1;
        random_twiddle_exponent[j+len] = new_random_twiddle_index_2;

        zeta1 = zetas_normal_order[index1];
        zeta2 = zetas_normal_order[index2];
        zeta3 = zetas_normal_order[index3];
        zeta4 = zetas_normal_order[index4];

        t1 = montgomery_reduce((uint64_t) zeta1 * p[j]);
        t2 = montgomery_reduce((uint64_t) zeta2 * p[j+len]);
        t3 = montgomery_reduce((uint64_t) zeta3 * p[j]);
        t4 = montgomery_reduce((uint64_t) zeta4 * p[j + len]);

        p[j] = t1 + t2;
        p[j + len] = t3 + 2*Q - t4;

      }
      k = k+1;
    }
    stage = stage+1;
  }

  for(j = 0; j < N; ++j)
  {
    p[j] = montgomery_reduce((uint64_t)f * p[j]);
  }
}

#elif (NTT_PROTECTION_MODE == GENERIC_MULTIPLICATIVE_MASKING)

void invntt_tomont(uint32_t p[N])
{
  #if(CALC_NTT_RAND_TIME == 1 || CALC_NTT_RAND_TIME_RAND == 1)
    randomize_intt_time = 0;
  #endif

  unsigned int start, len, j, k, k_prev;
  uint32_t t, zeta, zeta1, zeta2, zeta3, zeta4, t1, t2, t3, t4;
  uint16_t index1, index2, index3, index4, new_random_twiddle_index_1, new_random_twiddle_index_2, random_index;
  uint8_t stage = 0;

  const uint32_t f = (((uint64_t)MONT*MONT % Q) * (Q-1) % Q) * ((Q-1) >> 8) % Q;

  // Performing side channel resistant Inverse NTT structure with different twiddle factors...
  uint16_t random_twiddle_exponent[N]; //Generating random exponents for each stage...
  uint16_t sum_random_twiddle_exponent = 0;

  uint16_t new_random_twiddle_exponent[2*N];

  // No of masks:

  // uint8_t no_masks_per_stage_shift = get_random()%9;
  uint8_t no_masks_per_stage_shift = NO_MASKS_IN_STAGE;
  int no_masks_per_stage = (1 << no_masks_per_stage_shift);

  // Lets just ignore the first stage masking for now, as it might add some un-necessary overhead...

  unsigned int max_length_of_group = N/(no_masks_per_stage);
  uint8_t max_length_of_group_shift = 8 - no_masks_per_stage_shift;

  // SISO, if 2*len <= max_length_of_group...
  // SIDO if 1st stage and no_masks > 1...
  // DIDO if 2*len > max_length_of_group...

  uint16_t mask_refresh_no = 0;
  uint16_t mask_no = 0;
  uint16_t mask_j_exponent, mask_j_len_exponent;
  uint16_t mask_j_exponent_prev, mask_j_len_exponent_prev;
  uint16_t ii1, ii2, ii3;

  mask_j_exponent = 0x00;
  mask_j_len_exponent = 0x00;
  mask_j_exponent_prev = 0xFF;
  mask_j_len_exponent_prev = 0xFF;

  for(int i=0;i<N;i++)
  {
    // random_twiddle_exponent[i] = (get_random()+(256*get_random()))&((2*N)-1);
    random_twiddle_exponent[i] = 0;
    // p[i] = montgomery_reduce((uint64_t)p[i] * zetas_normal_order[random_twiddle_exponent[i]]);
  }

  k = 0;
  k_prev = 1;

  // printf("Start\n");
  for(len = 1; len < N; len <<= 1)
  {

    for(int i=0;i<no_masks_per_stage;i++)
    {
      if(len > 2)
      {
        // random_index = (get_random()*256)+get_random();

        // if(total_rand_bytes_remaining < 2)
        // {
        //
        //   #if(CALC_NTT_RAND_TIME_RAND == 1)
        //     t0_intt = hal_get_time();
        //   #endif
        //
        //   randombytes(random_buffer,RANDOM_BUFFER_SIZE);
        //   // prf(random_buffer, RANDOM_BUFFER_SIZE, seed, 0);
        //   total_rand_bytes_remaining = RANDOM_BUFFER_SIZE;
        //
        //   #if(CALC_NTT_RAND_TIME_RAND == 1)
        //
        //     t1_intt = hal_get_time();
        //     randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;
        //
        //   #endif
        // }
        //
        // random_index = random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining];
        // total_rand_bytes_remaining = total_rand_bytes_remaining-1;
        //
        // random_index = (random_index + random_buffer[RANDOM_BUFFER_SIZE - total_rand_bytes_remaining]);
        // total_rand_bytes_remaining = total_rand_bytes_remaining-1;

        if(total_rand_bits_remaining <= 9)
        {
          spare_random = random_index_global;
          spare_random_length = total_rand_bits_remaining;

          #if(CALC_NTT_RAND_TIME_RAND == 1)
            t0_intt = hal_get_time();
          #endif

          randombytes(random_buffer,RANDOM_BUFFER_SIZE);
          total_rand_bits_remaining = RANDOM_BUFFER_SIZE*8 + spare_random_length;

          random_index_global = (random_buffer[0]<<0) + (random_buffer[1]<<8) + (random_buffer[2]<<16)+ (random_buffer[3]<<24);

          #if(CALC_NTT_RAND_TIME_RAND == 1)
            t1_intt = hal_get_time();
            randomize_intt_time = randomize_intt_time + t1_intt - t0_intt;
          #endif
        }

        random_index = spare_random + (random_index_global & ((1 << (9 - spare_random_length)) - 1));
        random_index_global = random_index_global >> (9-spare_random_length);
        total_rand_bits_remaining = total_rand_bits_remaining - (9 - spare_random_length);
        spare_random_length = 0;

        new_random_twiddle_exponent[i] = (random_index)&((2*N)-1);
      }
      else
      {
        new_random_twiddle_exponent[i] = (2*N - random_twiddle_exponent[i])&((2*N)-1);
      }
    }

    if((2*len) > max_length_of_group) // DIDO...
    {
      // printf("DIDO\n");
      for(start = 0; start < N; start = j + len)
      {
        ii3 = inverse_zeta_order[k];

        for(j = start; j < start + len; ++j)
        {

          mask_j_exponent = j >> (max_length_of_group_shift);
          mask_j_len_exponent = (j+len) >> (max_length_of_group_shift);

          if((mask_j_exponent_prev != mask_j_exponent) || (k_prev != k))
          {

            k_prev = k;
            mask_j_exponent_prev = mask_j_exponent;
            mask_j_len_exponent_prev = mask_j_len_exponent;

            ii1 = 2*N - random_twiddle_exponent[mask_j_exponent];
            ii2 = 2*N - random_twiddle_exponent[mask_j_len_exponent];

            if(len == N/2)
            {
              index1 = (ii1)&((2*N)-1); //A1
              index2 = (ii2)&((2*N)-1); // B1
              index3 = (ii3 + ii1)&((2*N)-1); //A2
              index4 = (ii3 + ii2)&((2*N)-1); //B2
            }
            else
            {
              index1 = (ii1 + new_random_twiddle_exponent[mask_j_exponent])&((2*N)-1); //A1
              index2 = (ii2 + new_random_twiddle_exponent[mask_j_exponent])&((2*N)-1); // B1
              index3 = (inverse_zeta_order[k] + ii1 + new_random_twiddle_exponent[mask_j_len_exponent])&((2*N)-1); //A2
              index4 = (inverse_zeta_order[k] + ii2 + new_random_twiddle_exponent[mask_j_len_exponent])&((2*N)-1); //B2
            }
          }

          zeta1 = zetas_normal_order[index1];
          zeta2 = zetas_normal_order[index2];
          zeta3 = zetas_normal_order[index3];
          zeta4 = zetas_normal_order[index4];

          t1 = montgomery_reduce((uint64_t) zeta1 * p[j]);
          t2 = montgomery_reduce((uint64_t) zeta2 * p[j+len]);
          t3 = montgomery_reduce((uint64_t) zeta3 * p[j]);
          t4 = montgomery_reduce((uint64_t) zeta4 * p[j + len]);

          p[j] = t1 + t2;
          p[j + len] = t3 + 2*Q - t4;

        }
        k = k+1;
      }
      for(int i=0;i<no_masks_per_stage;i++)
      {
          random_twiddle_exponent[i] = new_random_twiddle_exponent[i];
      }
    }

    else if((2*len) <= max_length_of_group) // SISO...
    {
      // printf("SISO\n");
      for(start = 0; start < N; start = j + len)
      {
        ii3 = inverse_zeta_order[k];
        for(j = start; j < start + len; ++j)
        {

          mask_j_exponent = j >> (max_length_of_group_shift);

          if((mask_j_exponent_prev != mask_j_exponent) || (k_prev != k))
          {

            k_prev = k;
            mask_j_exponent_prev = mask_j_exponent;

            ii1 = 2*N - random_twiddle_exponent[mask_j_exponent];

            if(len == N/2)
            {
              index1 = (ii1)&((2*N)-1); //A1
              index3 = (ii3 + ii1)&((2*N)-1); //A2
            }
            else
            {
              index1 = (ii1 + new_random_twiddle_exponent[mask_j_exponent])&((2*N)-1); //A1
              index3 = (ii3 + ii1 + new_random_twiddle_exponent[mask_j_exponent])&((2*N)-1); //A2
            }
          }

          zeta1 = zetas_normal_order[index1];
          zeta3 = zetas_normal_order[index3];

          t = p[j];
          p[j] = montgomery_reduce((uint64_t)zeta1 * (t + p[j + len]));
          p[j + len] = t + 256*Q - p[j + len];
          p[j + len] = montgomery_reduce((uint64_t)zeta3 * p[j + len]);

        }
        k = k+1;
      }
      for(int i=0;i<no_masks_per_stage;i++)
      {
          random_twiddle_exponent[i] = new_random_twiddle_exponent[i];
      }
    }
  }

  for(j = 0; j < N; ++j)
  {
    p[j] = montgomery_reduce((uint64_t)f * p[j]);
  }
}

#endif
