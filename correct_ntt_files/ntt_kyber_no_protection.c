// #include "ntt.h"
//
// #include "params.h"
//
// #include <stdint.h>
//
// /* Code to generate zetas and zetas_inv used in the number-theoretic transform:
//
// #define KYBER_ROOT_OF_UNITY 17
//
// static const uint16_t tree[128] = {
//   0, 64, 32, 96, 16, 80, 48, 112, 8, 72, 40, 104, 24, 88, 56, 120,
//   4, 68, 36, 100, 20, 84, 52, 116, 12, 76, 44, 108, 28, 92, 60, 124,
//   2, 66, 34, 98, 18, 82, 50, 114, 10, 74, 42, 106, 26, 90, 58, 122,
//   6, 70, 38, 102, 22, 86, 54, 118, 14, 78, 46, 110, 30, 94, 62, 126,
//   1, 65, 33, 97, 17, 81, 49, 113, 9, 73, 41, 105, 25, 89, 57, 121,
//   5, 69, 37, 101, 21, 85, 53, 117, 13, 77, 45, 109, 29, 93, 61, 125,
//   3, 67, 35, 99, 19, 83, 51, 115, 11, 75, 43, 107, 27, 91, 59, 123,
//   7, 71, 39, 103, 23, 87, 55, 119, 15, 79, 47, 111, 31, 95, 63, 127};
//
//
// static int16_t fqmul(int16_t a, int16_t b) {
//   return montgomery_reduce((int32_t)a*b);
// }
//
// void init_ntt() {
//   unsigned int i, j, k;
//   int16_t tmp[128];
//
//   tmp[0] = MONT;
//   for(i = 1; i < 128; ++i)
//     tmp[i] = fqmul(tmp[i-1], KYBER_ROOT_OF_UNITY*MONT % KYBER_Q);
//
//   for(i = 0; i < 128; ++i)
//     zetas[i] = tmp[tree[i]];
//
//   k = 0;
//   for(i = 64; i >= 1; i >>= 1)
//     for(j = i; j < 2*i; ++j)
//       zetas_inv[k++] = -tmp[128 - tree[j]];
//
//   zetas_inv[127] = MONT * (MONT * (KYBER_Q - 1) * ((KYBER_Q - 1)/128) % KYBER_Q) % KYBER_Q;
// }
//
// */
//
// const int16_t zetas[64] = { 2226, 430, 555, 843, 2078, 871, 1550, 105, 422, 587, 177, 3094, 3038, 2869,
// 1574, 1653, 3083, 778, 1159, 3182, 2552, 1483, 2727, 1119, 1739, 644, 2457, 349,
// 418, 329, 3173, 3254, 817, 1097, 603, 610, 1322, 2044, 1864, 384, 2114, 3193,
// 1218, 1994, 2455, 220, 2142, 1670, 2144, 1799, 2051, 794, 1819, 2475, 2459, 478,
// 3221, 3021, 996, 991, 958, 1869, 1522, 1628 };
//
// const int16_t zetas_asm[128] = {
// // 7 & 6 & 5 layers
// 2571, 2970, 1812, 1493, 1422, 287, 202,
// // 1st loop of 4 & 3 & 2 layers
// 3158, 573, 2004, 1223, 652, 2777, 1015,
// // 2nd loop of 4 & 3 & 2 layers
// 622, 264, 383, 2036, 1491, 3047, 1785,
// // 3rd loop of 4 & 3 & 2 layers
// 1577, 2500, 1458, 516, 3321, 3009, 2663,
// // 4th loop of 4 & 3 & 2 layers
// 182, 1727, 3199, 1711, 2167, 126, 1469,
// // 5th loop of 4 & 3 & 2 layers
// 962, 2648, 1017, 2476, 3239, 3058, 830,
// // 6th loop of 4 & 3 & 2 layers
// 2127, 732, 608, 107, 1908, 3082, 2378,
// // 7th loop of 4 & 3 & 2 layers
// 1855, 1787, 411, 2931, 961, 1821, 2604,
// // 8th loop of 4 & 3 & 2 layers
// 1468, 3124, 1758, 448, 2264, 677, 2054,
// // 1 layer
// 2226, 430, 555, 843, 2078, 871, 1550, 105, 422, 587, 177, 3094, 3038, 2869, 1574, 1653, 3083, 778, 1159, 3182, 2552, 1483, 2727, 1119, 1739, 644, 2457, 349, 418, 329, 3173, 3254, 817, 1097, 603, 610, 1322, 2044, 1864, 384, 2114, 3193, 1218, 1994, 2455, 220, 2142, 1670, 2144, 1799, 2051, 794, 1819, 2475, 2459, 478, 3221, 3021, 996, 991, 958, 1869, 1522, 1628,
// };
//
// const int16_t zetas_inv_asm[128] = {
// // 1 layer
// 1701, 1807, 1460, 2371, 2338, 2333, 308, 108, 2851, 870, 854, 1510, 2535, 1278, 1530, 1185, 1659, 1187, 3109, 874, 1335, 2111, 136, 1215, 2945, 1465, 1285, 2007, 2719, 2726, 2232, 2512, 75, 156, 3000, 2911, 2980, 872, 2685, 1590, 2210, 602, 1846, 777, 147, 2170, 2551, 246, 1676, 1755, 460, 291, 235, 3152, 2742, 2907, 3224, 1779, 2458, 1251, 2486, 2774, 2899, 1103,
// // 1st loop of 2 & 3 & 4 layers
// 1275, 2652, 1065, 2881, 1571, 205, 1861,
// // 2nd loop of 2 & 3 & 4 layers
// 725, 1508, 2368, 398, 2918, 1542, 1474,
// // 3rd loop of 2 & 3 & 4 layers
// 951, 247, 1421, 3222, 2721, 2597, 1202,
// // 4th loop of 2 & 3 & 4 layers
// 2499, 271, 90, 853, 2312, 681, 2367,
// // 5th loop of 2 & 3 & 4 layers
// 1860, 3203, 1162, 1618, 130, 1602, 3147,
// // 6th loop of 2 & 3 & 4 layers
// 666, 320, 8, 2813, 1871, 829, 1752,
// // 7th loop of 2 & 3 & 4 layers
// 1544, 282, 1838, 1293, 2946, 3065, 2707,
// // 8th loop of 2 & 3 & 4 layers
// 2314, 552, 2677, 2106, 1325, 2756, 171,
// // 5 & 6 & 7 layers
// 3127, 3042, 1907, 1836, 1517, 359, 1932,
// // 128^-1 * 2^32
// 1441
// };
//
// extern void ntt_fast(int16_t *, const int16_t *);
// /*************************************************
// * Name:        ntt
// *
// * Description: Inplace number-theoretic transform (NTT) in Rq
// *              input is in standard order, output is in bitreversed order
// *
// * Arguments:   - int16_t *poly: pointer to input/output vector of 256 elements of Zq
// **************************************************/
// void ntt(int16_t *poly) {
//     ntt_fast(poly, zetas_asm);
// }
//
// extern void invntt_fast(int16_t *, const int16_t *);
// /*************************************************
// * Name:        invntt
// *
// * Description: Inplace inverse number-theoretic transform in Rq
// *              input is in bitreversed order, output is in standard order
// *
// * Arguments:   - int16_t *poly: pointer to input/output vector of 256 elements of Zq
// **************************************************/
// void invntt(int16_t *poly) {
//     invntt_fast(poly, zetas_inv_asm);
// }

#include <stdint.h>
#include "params.h"
#include "ntt.h"
#include "reduce.h"
#include "randombytes.h"

/* Code to generate zetas and zetas_inv used in the number-theoretic transform:

#define KYBER_ROOT_OF_UNITY 17

static const uint16_t tree[128] = {
  0, 64, 32, 96, 16, 80, 48, 112, 8, 72, 40, 104, 24, 88, 56, 120,
  4, 68, 36, 100, 20, 84, 52, 116, 12, 76, 44, 108, 28, 92, 60, 124,
  2, 66, 34, 98, 18, 82, 50, 114, 10, 74, 42, 106, 26, 90, 58, 122,
  6, 70, 38, 102, 22, 86, 54, 118, 14, 78, 46, 110, 30, 94, 62, 126,
  1, 65, 33, 97, 17, 81, 49, 113, 9, 73, 41, 105, 25, 89, 57, 121,
  5, 69, 37, 101, 21, 85, 53, 117, 13, 77, 45, 109, 29, 93, 61, 125,
  3, 67, 35, 99, 19, 83, 51, 115, 11, 75, 43, 107, 27, 91, 59, 123,
  7, 71, 39, 103, 23, 87, 55, 119, 15, 79, 47, 111, 31, 95, 63, 127
};

void init_ntt() {
  unsigned int i, j, k;
  int16_t tmp[128];

  tmp[0] = MONT;
  for(i = 1; i < 128; ++i)
    tmp[i] = fqmul(tmp[i-1], KYBER_ROOT_OF_UNITY*MONT % KYBER_Q);

  for(i = 0; i < 128; ++i)
    zetas[i] = tmp[tree[i]];

  k = 0;
  for(i = 64; i >= 1; i >>= 1)
    for(j = i; j < 2*i; ++j)
      zetas_inv[k++] = -tmp[128 - tree[j]];

  zetas_inv[127] = MONT * (MONT * (KYBER_Q - 1) * ((KYBER_Q - 1)/128) % KYBER_Q) % KYBER_Q;
}

*/

// NTT protection...

#define NO_PROTECTION 0
#define COARSE_SHUFFLING 1
#define GROUP_COARSE_SHUFFLING 2
#define GROUP_SHUFFLING 4
#define FINE_SHUFFLING 8
#define COARSE_MULTIPLICATIVE_MASKING 16
#define FINE_MULTIPLICATIVE_MASKING 32

#define NTT_PROTECTION_MODE NO_PROTECTION

const int16_t zetas_poly[64] = { 2226, 430, 555, 843, 2078, 871, 1550, 105, 422, 587, 177, 3094, 3038, 2869,
1574, 1653, 3083, 778, 1159, 3182, 2552, 1483, 2727, 1119, 1739, 644, 2457, 349,
418, 329, 3173, 3254, 817, 1097, 603, 610, 1322, 2044, 1864, 384, 2114, 3193,
1218, 1994, 2455, 220, 2142, 1670, 2144, 1799, 2051, 794, 1819, 2475, 2459, 478,
3221, 3021, 996, 991, 958, 1869, 1522, 1628 };

static const uint8_t bitrev_order[128] = {
  0, 64, 32, 96, 16, 80, 48, 112, 8, 72, 40, 104, 24, 88, 56, 120, 4, 68, 36, 100, 20, 84, 52, 116, 12, 76, 44,
  108, 28, 92, 60, 124, 2, 66, 34, 98, 18, 82, 50, 114, 10, 74, 42, 106, 26, 90, 58, 122, 6, 70, 38, 102, 22, 86,
  54, 118, 14, 78, 46, 110, 30, 94, 62, 126, 1, 65, 33, 97, 17, 81, 49, 113, 9, 73, 41, 105, 25, 89, 57, 121, 5,
  69, 37, 101, 21, 85, 53, 117, 13, 77, 45, 109, 29, 93, 61, 125, 3, 67, 35, 99, 19, 83, 51, 115, 11, 75, 43, 107,
  27, 91, 59, 123, 7, 71, 39, 103, 23, 87, 55, 119, 15, 79, 47, 111, 31, 95, 63, 127
};
// Code to generate zetas and zetas_inv used in the number-theoretic transform:

#define KYBER_ROOT_OF_UNITY 17
#define NO_STAGES 7

static const uint16_t tree[128] = {
  0, 64, 32, 96, 16, 80, 48, 112, 8, 72, 40, 104, 24, 88, 56, 120,
  4, 68, 36, 100, 20, 84, 52, 116, 12, 76, 44, 108, 28, 92, 60, 124,
  2, 66, 34, 98, 18, 82, 50, 114, 10, 74, 42, 106, 26, 90, 58, 122,
  6, 70, 38, 102, 22, 86, 54, 118, 14, 78, 46, 110, 30, 94, 62, 126,
  1, 65, 33, 97, 17, 81, 49, 113, 9, 73, 41, 105, 25, 89, 57, 121,
  5, 69, 37, 101, 21, 85, 53, 117, 13, 77, 45, 109, 29, 93, 61, 125,
  3, 67, 35, 99, 19, 83, 51, 115, 11, 75, 43, 107, 27, 91, 59, 123,
  7, 71, 39, 103, 23, 87, 55, 119, 15, 79, 47, 111, 31, 95, 63, 127
};

const int16_t zetas[128] = {
  2285, 2571, 2970, 1812, 1493, 1422, 287, 202, 3158, 622, 1577, 182, 962,
  2127, 1855, 1468, 573, 2004, 264, 383, 2500, 1458, 1727, 3199, 2648, 1017,
  732, 608, 1787, 411, 3124, 1758, 1223, 652, 2777, 1015, 2036, 1491, 3047,
  1785, 516, 3321, 3009, 2663, 1711, 2167, 126, 1469, 2476, 3239, 3058, 830,
  107, 1908, 3082, 2378, 2931, 961, 1821, 2604, 448, 2264, 677, 2054, 2226,
  430, 555, 843, 2078, 871, 1550, 105, 422, 587, 177, 3094, 3038, 2869, 1574,
  1653, 3083, 778, 1159, 3182, 2552, 1483, 2727, 1119, 1739, 644, 2457, 349,
  418, 329, 3173, 3254, 817, 1097, 603, 610, 1322, 2044, 1864, 384, 2114, 3193,
  1218, 1994, 2455, 220, 2142, 1670, 2144, 1799, 2051, 794, 1819, 2475, 2459,
  478, 3221, 3021, 996, 991, 958, 1869, 1522, 1628
};

static const int16_t zetas_normal_order[256] = {
  2285, -1103, 1223, 817, 573, -246, -853, -1185, -171, 422, 516, -1215, -681, -1590, -398, -108, 1493, -1251, -1293,
  1322, -829, -777, 107, -1510, 962, -291, -1618, -874, -1542, 418, 448, 958, -359, 555, -552, 603, 264, 1159, -271,
  -1278, 1577, 177, -320, 1218, 732, -872, -1508, 996, 287, 1550, -282, -1465, -1602, -602, -247, -870, -1474, 1574,
  126, -1187, -205, -156, 677, 1522, -758, 430, 652, 1097, -1325, 778, -90, -1530, 622, 587, -8, -136, 1017, 644,
  961, -308, 1422, 871, 1491, -1285, 1458, 1483, -1421, -854, -1202, -460, -1162, 220, 411, 329, -1065, -1460, -1517,
  843, 1015, 610, 383, -147, 830, 794, 182, -235, -666, -1335, 608, 349, -725, 991, 202, 105, -1544, 384, -130, 1119,
  -951, 478, 1468, 1653, 1469, 1670, -1571, -75, -1275, -1701, 1044, 1103, -1223, -817, -573, 246, 853, 1185, 171,
  -422, -516, 1215, 681, 1590, 398, 108, -1493, 1251, 1293, -1322, 829, 777, -107, 1510, -962, 291, 1618, 874, 1542,
  -418, -448, -958, 359, -555, 552, -603, -264, -1159, 271, 1278, -1577, -177, 320, -1218, -732, 872, 1508, -996, -287,
  -1550, 282, 1465, 1602, 602, 247, 870, 1474, -1574, -126, 1187, 205, 156, -677, -1522, 758, -430, -652, -1097, 1325,
  -778, 90, 1530, -622, -587, 8, 136, -1017, -644, -961, 308, -1422, -871, -1491, 1285, -1458, -1483, 1421, 854, 1202,
  460, 1162, -220, -411, -329, 1065, 1460, 1517, -843, -1015, -610, -383, 147, -830, -794, -182, 235, 666, 1335, -608,
  -349, 725, -991, -202, -105, 1544, -384, 130, -1119, 951, -478, -1468, -1653, -1469, -1670, 1571, 75, 1275, 1701
};

static const uint8_t inverse_zeta_order[127] = {255, 191, 223, 159, 239, 175, 207, 143, 247, 183, 215, 151, 231, 167, 199, 135, 251, 187,
  219, 155, 235, 171, 203, 139, 243, 179, 211, 147, 227, 163, 195, 131, 253, 189, 221, 157, 237, 173, 205, 141, 245,
  181, 213, 149, 229, 165, 197, 133, 249, 185, 217, 153, 233, 169, 201, 137, 241, 177, 209, 145, 225, 161, 193, 129,
  254, 190, 222, 158, 238, 174, 206, 142, 246, 182, 214, 150, 230, 166, 198, 134, 250, 186, 218, 154, 234, 170, 202,
  138, 242, 178, 210, 146, 226, 162, 194, 130, 252, 188, 220, 156, 236, 172, 204, 140, 244, 180, 212, 148, 228, 164,
  196, 132, 248, 184, 216, 152, 232, 168, 200, 136, 240, 176, 208, 144, 224, 160, 192};

#define ZETA_INV_127 1441

const int16_t zetas_inv[128] = {
  1701, 1807, 1460, 2371, 2338, 2333, 308, 108, 2851, 870, 854, 1510, 2535,
  1278, 1530, 1185, 1659, 1187, 3109, 874, 1335, 2111, 136, 1215, 2945, 1465,
  1285, 2007, 2719, 2726, 2232, 2512, 75, 156, 3000, 2911, 2980, 872, 2685,
  1590, 2210, 602, 1846, 777, 147, 2170, 2551, 246, 1676, 1755, 460, 291, 235,
  3152, 2742, 2907, 3224, 1779, 2458, 1251, 2486, 2774, 2899, 1103, 1275, 2652,
  1065, 2881, 725, 1508, 2368, 398, 951, 247, 1421, 3222, 2499, 271, 90, 853,
  1860, 3203, 1162, 1618, 666, 320, 8, 2813, 1544, 282, 1838, 1293, 2314, 552,
  2677, 2106, 1571, 205, 2918, 1542, 2721, 2597, 2312, 681, 130, 1602, 1871,
  829, 2946, 3065, 1325, 2756, 1861, 1474, 1202, 2367, 3147, 1752, 2707, 171,
  3127, 3042, 1907, 1836, 1517, 359, 758, 1441
};

// unsigned char ordered_array[256] = {
// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
// 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
// 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
// 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120,
// 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146,
// 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172,
// 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198,
// 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224,
// 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250,
// 251, 252, 253, 254, 255};

uint8_t ordered_array[128] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
    45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
    70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,
    95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115,
    116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127};

uint8_t multi_ordered_array[7][128] = {
  {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127}
};

uint8_t multi_ordered_array_dup[7][128] = {
  {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127}
};

static const uint8_t index_array[8][128] = {
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127},
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191},
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223},
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239},
    {0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23, 32, 33, 34, 35, 36, 37, 38, 39, 48, 49, 50, 51, 52, 53, 54, 55, 64, 65, 66, 67, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 96, 97, 98, 99, 100, 101, 102, 103, 112, 113, 114, 115, 116, 117, 118, 119, 128, 129, 130, 131, 132, 133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 151, 160, 161, 162, 163, 164, 165, 166, 167, 176, 177, 178, 179, 180, 181, 182, 183, 192, 193, 194, 195, 196, 197, 198, 199, 208, 209, 210, 211, 212, 213, 214, 215, 224, 225, 226, 227, 228, 229, 230, 231, 240, 241, 242, 243, 244, 245, 246, 247},
    {0, 1, 2, 3, 8, 9, 10, 11, 16, 17, 18, 19, 24, 25, 26, 27, 32, 33, 34, 35, 40, 41, 42, 43, 48, 49, 50, 51, 56, 57, 58, 59, 64, 65, 66, 67, 72, 73, 74, 75, 80, 81, 82, 83, 88, 89, 90, 91, 96, 97, 98, 99, 104, 105, 106, 107, 112, 113, 114, 115, 120, 121, 122, 123, 128, 129, 130, 131, 136, 137, 138, 139, 144, 145, 146, 147, 152, 153, 154, 155, 160, 161, 162, 163, 168, 169, 170, 171, 176, 177, 178, 179, 184, 185, 186, 187, 192, 193, 194, 195, 200, 201, 202, 203, 208, 209, 210, 211, 216, 217, 218, 219, 224, 225, 226, 227, 232, 233, 234, 235, 240, 241, 242, 243, 248, 249, 250, 251},
    {0, 1, 4, 5, 8, 9, 12, 13, 16, 17, 20, 21, 24, 25, 28, 29, 32, 33, 36, 37, 40, 41, 44, 45, 48, 49, 52, 53, 56, 57, 60, 61, 64, 65, 68, 69, 72, 73, 76, 77, 80, 81, 84, 85, 88, 89, 92, 93, 96, 97, 100, 101, 104, 105, 108, 109, 112, 113, 116, 117, 120, 121, 124, 125, 128, 129, 132, 133, 136, 137, 140, 141, 144, 145, 148, 149, 152, 153, 156, 157, 160, 161, 164, 165, 168, 169, 172, 173, 176, 177, 180, 181, 184, 185, 188, 189, 192, 193, 196, 197, 200, 201, 204, 205, 208, 209, 212, 213, 216, 217, 220, 221, 224, 225, 228, 229, 232, 233, 236, 237, 240, 241, 244, 245, 248, 249, 252, 253}
};

static const uint8_t twiddle_factor_index_array[8][128] = {
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
    {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7},
    {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
    {16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31},
    {32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58, 58, 59, 59, 59, 59, 60, 60, 60, 60, 61, 61, 61, 61, 62, 62, 62, 62, 63, 63, 63, 63},
    {64, 64, 65, 65, 66, 66, 67, 67, 68, 68, 69, 69, 70, 70, 71, 71, 72, 72, 73, 73, 74, 74, 75, 75, 76, 76, 77, 77, 78, 78, 79, 79, 80, 80, 81, 81, 82, 82, 83, 83, 84, 84, 85, 85, 86, 86, 87, 87, 88, 88, 89, 89, 90, 90, 91, 91, 92, 92, 93, 93, 94, 94, 95, 95, 96, 96, 97, 97, 98, 98, 99, 99, 100, 100, 101, 101, 102, 102, 103, 103, 104, 104, 105, 105, 106, 106, 107, 107, 108, 108, 109, 109, 110, 110, 111, 111, 112, 112, 113, 113, 114, 114, 115, 115, 116, 116, 117, 117, 118, 118, 119, 119, 120, 120, 121, 121, 122, 122, 123, 123, 124, 124, 125, 125, 126, 126, 127, 127}
};

static const uint8_t inverse_index_array[7][128] = {
  {0, 1, 4, 5, 8, 9, 12, 13, 16, 17, 20, 21, 24, 25, 28, 29, 32, 33, 36, 37, 40, 41, 44, 45, 48, 49, 52, 53, 56, 57, 60, 61, 64, 65, 68, 69, 72, 73, 76, 77, 80, 81, 84, 85, 88, 89, 92, 93, 96, 97, 100, 101, 104, 105, 108, 109, 112, 113, 116, 117, 120, 121, 124, 125, 128, 129, 132, 133, 136, 137, 140, 141, 144, 145, 148, 149, 152, 153, 156, 157, 160, 161, 164, 165, 168, 169, 172, 173, 176, 177, 180, 181, 184, 185, 188, 189, 192, 193, 196, 197, 200, 201, 204, 205, 208, 209, 212, 213, 216, 217, 220, 221, 224, 225, 228, 229, 232, 233, 236, 237, 240, 241, 244, 245, 248, 249, 252, 253},
  {0, 1, 2, 3, 8, 9, 10, 11, 16, 17, 18, 19, 24, 25, 26, 27, 32, 33, 34, 35, 40, 41, 42, 43, 48, 49, 50, 51, 56, 57, 58, 59, 64, 65, 66, 67, 72, 73, 74, 75, 80, 81, 82, 83, 88, 89, 90, 91, 96, 97, 98, 99, 104, 105, 106, 107, 112, 113, 114, 115, 120, 121, 122, 123, 128, 129, 130, 131, 136, 137, 138, 139, 144, 145, 146, 147, 152, 153, 154, 155, 160, 161, 162, 163, 168, 169, 170, 171, 176, 177, 178, 179, 184, 185, 186, 187, 192, 193, 194, 195, 200, 201, 202, 203, 208, 209, 210, 211, 216, 217, 218, 219, 224, 225, 226, 227, 232, 233, 234, 235, 240, 241, 242, 243, 248, 249, 250, 251},
  {0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23, 32, 33, 34, 35, 36, 37, 38, 39, 48, 49, 50, 51, 52, 53, 54, 55, 64, 65, 66, 67, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 96, 97, 98, 99, 100, 101, 102, 103, 112, 113, 114, 115, 116, 117, 118, 119, 128, 129, 130, 131, 132, 133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 151, 160, 161, 162, 163, 164, 165, 166, 167, 176, 177, 178, 179, 180, 181, 182, 183, 192, 193, 194, 195, 196, 197, 198, 199, 208, 209, 210, 211, 212, 213, 214, 215, 224, 225, 226, 227, 228, 229, 230, 231, 240, 241, 242, 243, 244, 245, 246, 247},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191},
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127}
};

static const uint8_t inverse_twiddle_factor_index_array[7][128] = {
  {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37, 38, 38, 39, 39, 40, 40, 41, 41, 42, 42, 43, 43, 44, 44, 45, 45, 46, 46, 47, 47, 48, 48, 49, 49, 50, 50, 51, 51, 52, 52, 53, 53, 54, 54, 55, 55, 56, 56, 57, 57, 58, 58, 59, 59, 60, 60, 61, 61, 62, 62, 63, 63},
  {64, 64, 64, 64, 65, 65, 65, 65, 66, 66, 66, 66, 67, 67, 67, 67, 68, 68, 68, 68, 69, 69, 69, 69, 70, 70, 70, 70, 71, 71, 71, 71, 72, 72, 72, 72, 73, 73, 73, 73, 74, 74, 74, 74, 75, 75, 75, 75, 76, 76, 76, 76, 77, 77, 77, 77, 78, 78, 78, 78, 79, 79, 79, 79, 80, 80, 80, 80, 81, 81, 81, 81, 82, 82, 82, 82, 83, 83, 83, 83, 84, 84, 84, 84, 85, 85, 85, 85, 86, 86, 86, 86, 87, 87, 87, 87, 88, 88, 88, 88, 89, 89, 89, 89, 90, 90, 90, 90, 91, 91, 91, 91, 92, 92, 92, 92, 93, 93, 93, 93, 94, 94, 94, 94, 95, 95, 95, 95},
  {96, 96, 96, 96, 96, 96, 96, 96, 97, 97, 97, 97, 97, 97, 97, 97, 98, 98, 98, 98, 98, 98, 98, 98, 99, 99, 99, 99, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100, 100, 100, 101, 101, 101, 101, 101, 101, 101, 101, 102, 102, 102, 102, 102, 102, 102, 102, 103, 103, 103, 103, 103, 103, 103, 103, 104, 104, 104, 104, 104, 104, 104, 104, 105, 105, 105, 105, 105, 105, 105, 105, 106, 106, 106, 106, 106, 106, 106, 106, 107, 107, 107, 107, 107, 107, 107, 107, 108, 108, 108, 108, 108, 108, 108, 108, 109, 109, 109, 109, 109, 109, 109, 109, 110, 110, 110, 110, 110, 110, 110, 110, 111, 111, 111, 111, 111, 111, 111, 111},
  {112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119},
  {120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123},
  {124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125},
  {126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126},
};

static int shift_lfsr(unsigned int *lfsr, unsigned int polynomial_mask)
{
    int feedback;

    feedback = *lfsr & 1;
    *lfsr >>= 1;
    if(feedback == 1)
        *lfsr ^= polynomial_mask;
    return *lfsr;
}

static int get_random(void)
{
    int temp;
    unsigned int POLY_MASK_HERE_1 = 0xB765879A;
    unsigned int POLY_MASK_HERE_2 = 0x55BBEEFF;
    static unsigned int lfsr_1 = 0x55AAEEFF;
    static unsigned int lfsr_2 = 0xFFAA8844;
    shift_lfsr(&lfsr_1, POLY_MASK_HERE_1);
    shift_lfsr(&lfsr_2, POLY_MASK_HERE_2);
    temp = (shift_lfsr(&lfsr_1, POLY_MASK_HERE_1) ^ shift_lfsr(&lfsr_2, POLY_MASK_HERE_2)) & 0XFF;
    // printf("%02x\n",temp);
    return (temp);
}

// A utility function to swap to integers
static void swap (unsigned char *a, unsigned char *b)
{
    unsigned char temp = *a;
    *a = *b;
    *b = temp;
}

// A function to generate a random
// permutation of arr[]
static void randomize (unsigned char arr[], int n)
{
  unsigned char temp;
    // Start from the last element and swap
    // one by one. We don't need to run for
    // the first element that's why i > 0
    for (int i = n - 1; i > 0; i--)
    {
        randombytes(&temp,1);
        // temp = get_random();
        // Pick a random index from 0 to i
        int j = temp % (i + 1);

        // Swap arr[i] with the element
        // at random index
        swap(&arr[i], &arr[j]);
    }

}

// Calculate reversebits of a number (Count means the number of bits in the number)
static int reverseBits(int num, int count)
{
    int mask = 0x1FF;
    num = num & mask;
    int reverse_num = 0;
    char bit=0;
    for(int i=count-1;i>=0;i--)
    {
        bit=(num&0b1);
        reverse_num = reverse_num + (bit<<i);
        num >>=1;
    }
    return reverse_num;
}

/*************************************************
* Name:        fqmul
*
* Description: Multiplication followed by Montgomery reduction
*
* Arguments:   - int16_t a: first factor
*              - int16_t b: second factor
*
* Returns 16-bit integer congruent to a*b*R^{-1} mod q
**************************************************/
static int16_t fqmul(int16_t a, int16_t b) {
  return montgomery_reduce((int32_t)a*b);
}

/*************************************************
* Name:        ntt
*
* Description: Inplace number-theoretic transform (NTT) in Rq
*              input is in standard order, output is in bitreversed order
*
* Arguments:   - int16_t r[256]: pointer to input/output vector of elements
*                                of Zq
**************************************************/

#if (NTT_PROTECTION_MODE == NO_PROTECTION)

void ntt(int16_t r[256])
{
  unsigned int len, start, j, k;
  int16_t t, zeta;

  k = 1;
  for(len = 128; len >= 2; len >>= 1)
  {
    for(start = 0; start < 256; start = j + len)
    {
      zeta = zetas[k++];
      for(j = start; j < start + len; ++j)
      {
        // Loading r[j+len]
        t = fqmul(zeta, r[j + len]);
        r[j + len] = r[j] - t;
        r[j] = r[j] + t;
      }
    }
  }
}

#elif (NTT_PROTECTION_MODE == GROUP_COARSE_SHUFFLING)

// Coarse shuffing within groups...

void ntt(int16_t r[256])
{
  // printf("Here\n");
  unsigned int len, start, j, k;
  int16_t t, zeta;
  uint8_t len1,temp;

  k = 1;
  for(len = 7; len >= 1; len--)
  {
    // printf("len: %d\n", len);
    len1 = (1 << len);
    for(start = 0; start < 256; start = j + len1)
    {
      zeta = zetas[k++];
      randomize(&(multi_ordered_array[len-1][0]), len1);

      for(j = start; j < start + len1; ++j)
      {
        temp = multi_ordered_array[len-1][j-start] + start;

        t = fqmul(zeta, r[temp + len1]);
        r[temp + len1] = r[temp] - t;
        r[temp] = r[temp] + t;
      }
    }
  }
}

#elif (NTT_PROTECTION_MODE == GROUP_SHUFFLING)

void ntt(int16_t r[256])
{
  unsigned int len, start, j, k, g;
  int16_t t, zeta;
  uint8_t len1,temp,no_groups,row_no,stage;

  stage = 0;
  for(len = 7; len >= 1; len--)
  {
    len1 = (1 << len);
    no_groups = 128/len1;
    row_no = 6 - len;
    if(no_groups > 1)
    {
     randomize(&(multi_ordered_array[row_no][0]), no_groups);

      for(g = 0; g < no_groups; g++)
      {
        start = (multi_ordered_array[row_no][g])*2*len1;
        zeta = zetas[twiddle_factor_index_array[stage][start/2]];

        for(j = start; j < start + len1; ++j)
        {
          t = fqmul(zeta, r[j + len1]);
          r[j + len1] = r[j] - t;
          r[j] = r[j] + t;
        }
      }
    }
    else
    {
      randomize(ordered_array, 128);
      for(start = 0; start < 128; start++)
      {
        temp = ordered_array[start];
        zeta = zetas[twiddle_factor_index_array[stage][temp]];
        // printf("zeta: %d\n",zeta);
        temp = index_array[stage][temp];
        // printf("j: %d\n",temp);
        t = fqmul(zeta, r[temp + len1]);
        r[temp + len1] = r[temp] - t;
        r[temp] = r[temp] + t;
      }
    }
    stage = stage+1;
  }
}

#elif (NTT_PROTECTION_MODE == COARSE_SHUFFLING)

// Coarse Shuffling...

void ntt(int16_t r[256])
{

  unsigned int len, start, j, k;
  int16_t t, zeta;
  uint8_t temp;
  uint8_t stage;

  k = 1;

  stage = 0;
  for(len = 128; len >= 2; len >>= 1)
  {
    randomize(&multi_ordered_array[6][0], 128);
    for(start = 0; start < 128; start++)
    {
      temp = multi_ordered_array[6][start];
      zeta = zetas[twiddle_factor_index_array[stage][temp]];
      temp = index_array[stage][temp];

      t = fqmul(zeta, r[temp + len]);
      r[temp + len] = r[temp] - t;
      r[temp] = r[temp] + t;
    }
    stage++;
  }

}

#elif (NTT_PROTECTION_MODE == FINE_SHUFFLING)

// Fine Shulffing...

void ntt(int16_t r[256])
{
  unsigned int len, start, j, k;
  int16_t t, zeta;
  int16_t op1, op2, temp, out1, out2;
  uint8_t randi, bitrand;
  int16_t mask;

  k = 1;
  int count = 0;

  // printf("Shuffled NTT\n");
  for(len = 128; len >= 2; len >>= 1)
  {
    for(start = 0; start < 256; start = j + len)
    {
      zeta = zetas[k++];
      for(j = start; j < start + len; ++j)
      {
        if((count&0x7) == 0)
        {
         // randi = get_random();
          randombytes(&randi,1);
        }

        bitrand = randi>>(count&0x7)&0x1;
        mask = -1*(bitrand);
        count = count+1;

        op1 = r[j+bitrand*len];
        op2 = r[j+(1-bitrand)*len];
        // cswap...
        temp = (op1 ^ op2)&mask;
        op1 = op1 ^ temp;
        op2 = op2 ^ temp;

        t = fqmul(zeta, op2);
        out1 = op1 + t;
        out2 = op1 - t;

        if((count&0x7) == 0)
        {
          // randi = get_random();
          randombytes(&randi,1);
        }

        bitrand = randi>>(count&0x7)&0x1;
        mask = -1*(bitrand);
        count = count+1;

        temp = (out1 ^ out2)&mask;
        out1 = out1 ^ temp;
        out2 = out2 ^ temp;

        r[j+(bitrand)*len] = out1;
        r[j+(1-bitrand)*len] = out2;

      }
    }
  }
}

#elif (NTT_PROTECTION_MODE == COARSE_MULTIPLICATIVE_MASKING)

// Coarse Multiplicative masking...

void ntt(int16_t r[256])
{
  // printf("Enter...\n");
  unsigned int len, start, j, k;
  int16_t t, zeta, zeta1, zeta2, t1, t2;
  uint8_t temp;
  uint8_t stage = 0;

  k = 1;

  uint8_t random_index;

  // Performing side channel resistant Inverse NTT structure with different twiddle factors...
  int16_t random_twiddle_exponent[7]; //Generating random exponents for each stage...
  uint16_t sum_random_twiddle_exponent = 0;

  uint8_t index1, index2;

  for(int i=0;i<(NO_STAGES-1);i++)
  {
    // random_index = get_random();
    randombytes(&random_index,1);
    random_twiddle_exponent[i] = (random_index)&((KYBER_N)-1);
    // printf("%d, ",random_twiddle_exponent[i]);
    sum_random_twiddle_exponent += random_twiddle_exponent[i];
    // printf("%d, ",random_twiddle_exponent[i]);
  }

  random_twiddle_exponent[6] = (KYBER_N) - (sum_random_twiddle_exponent&((KYBER_N)-1));
  // printf("%d, ",random_twiddle_exponent[6]);

  k = 1;
  for(len = 128; len >= 2; len >>= 1)
  {
    for(start = 0; start < 256; start = j + len)
    {
      index1 = (bitrev_order[k] + random_twiddle_exponent[stage])&0xFF; // Correct...
      index2 = random_twiddle_exponent[stage];
      // printf("%d, %d, %d\n",stage,index1,index2);

      // zeta = zetas[k++];

      zeta1 = zetas_normal_order[index1];
      zeta2 = zetas_normal_order[index2];

      for(j = start; j < start + len; ++j)
      {
        t1 = fqmul(zeta1, r[j + len]);
        t2 = fqmul(zeta2, r[j]);
        r[j + len] = t2 - t1;
        r[j] = t2 + t1;
      }
      k = k+1;
    }
    stage = stage+1;
    // printf("stage: %d\n",stage);
  }
  // printf("Done...\n");
}

#elif (NTT_PROTECTION_MODE == FINE_MULTIPLICATIVE_MASKING)

// Fine Multiplicative masking...

void ntt(int16_t r[256])
{
  // printf("Enter...\n");
  unsigned int len, start, j, k;
  int16_t t, zeta, zeta1, zeta2, zeta3, zeta4, t1, t2, t3, t4;
  uint8_t index1, index2, index3, index4;
  uint8_t temp;
  uint8_t stage = 0;
  uint8_t new_random_twiddle_index_1, new_random_twiddle_index_2;

  k = 1;

  uint8_t random_index, ii1, ii2;

  // Performing side channel resistant Inverse NTT structure with different twiddle factors...
  int16_t random_twiddle_exponent[KYBER_N]; //Generating random exponents for each stage...

  for(int i=0;i<KYBER_N;i++)
  {
    // random_index = get_random();
    randombytes(&random_index,1);
    random_twiddle_exponent[i] = (random_index)&((KYBER_N)-1);
    r[i] = fqmul(r[i],zetas_normal_order[random_twiddle_exponent[i]]);
  }

  k = 1;
  for(len = 128; len >= 2; len >>= 1)
  {
    for(start = 0; start < 256; start = j + len)
    {
      random_index = bitrev_order[k];
      for(j = start; j < start + len; ++j)
      {
        ii1 = 256 - random_twiddle_exponent[j];
        ii2 = 256 - random_twiddle_exponent[j+len];

        if(len == 2)
        {
          index1 = ii1; //A1
          index2 = (random_index + ii2)&0xFF; //B1
          index3 = ii1; //A2
          index4 = (random_index + ii2)&0xFF; //B2
        }
        else
        {
          // new_random_twiddle_index_1 = get_random();
          randombytes(random_twiddle_exponent+j,1);
          // new_random_twiddle_index_2 = get_random();
          randombytes(random_twiddle_exponent+j+len,1);

          index1 = (ii1 + random_twiddle_exponent[j])&0xFF; //A1
          index2 = (random_index + ii2 + random_twiddle_exponent[j])&0xFF; //B1
          index3 = (ii1 + random_twiddle_exponent[j+len])&0xFF; //A2
          index4 = (random_index + ii2 + random_twiddle_exponent[j+len])&0xFF; //B2
        }

        // random_twiddle_exponent[j] = new_random_twiddle_index_1;
        // random_twiddle_exponent[j+len] = new_random_twiddle_index_2;

        zeta1 = zetas_normal_order[index1];
        zeta2 = zetas_normal_order[index2];
        zeta3 = zetas_normal_order[index3];
        zeta4 = zetas_normal_order[index4];

        t1 = fqmul(zeta1, r[j]);
        t2 = fqmul(zeta2, r[j+len]);
        t3 = fqmul(zeta3, r[j]);
        t4 = fqmul(zeta4, r[j + len]);

        r[j] = t1 + t2;
        r[j + len] = t3 - t4;

      }
      k = k+1;
    }
    // stage = stage+1;
    // printf("stage: %d\n",stage);
  }
  // printf("Done...\n");
}

#endif

/*************************************************
* Name:        invntt_tomont
*
* Description: Inplace inverse number-theoretic transform in Rq and
*              multiplication by Montgomery factor 2^16.
*              Input is in bitreversed order, output is in standard order
*
* Arguments:   - int16_t r[256]: pointer to input/output vector of elements
*                                of Zq
**************************************************/

#if (NTT_PROTECTION_MODE == NO_PROTECTION)

void invntt(int16_t r[256])
{
  unsigned int start, len, j, k;
  int16_t t, zeta;

  k = 0;
  for(len = 2; len <= 128; len <<= 1)
  {
    for(start = 0; start < 256; start = j + len)
    {
      zeta = zetas_inv[k++];
      // printf("%d, ",zeta);
      for(j = start; j < start + len; ++j)
      {
        t = r[j];
        r[j] = barrett_reduce(t + r[j + len]);
        r[j + len] = t - r[j + len];
        r[j + len] = fqmul(zeta, r[j + len]);
      }
    }
  }
  // printf("\n");

  for(j = 0; j < 256; ++j)
    r[j] = fqmul(r[j], zetas_inv[127]);
}

#elif (NTT_PROTECTION_MODE == GROUP_COARSE_SHUFFLING)

// Coarse shuffling within groups...

void invntt(int16_t r[256])
{
  unsigned int start, len, j, k;
  int16_t t, zeta;
  uint8_t len1,temp;

  k = 0;
  for(len = 1; len <= 7; len++)
  {
    len1 = 1 << len;
    for(start = 0; start < 256; start = j + len1)
    {
      zeta = zetas_inv[k++];
      randomize(&(multi_ordered_array[len-1][0]), len1);

      for(j = start; j < start + len1; ++j)
      {
        temp = multi_ordered_array[len-1][j-start] + start;

        t = r[temp];
        r[temp] = barrett_reduce(t + r[temp + len1]);
        r[temp + len1] = t - r[temp + len1];
        r[temp + len1] = fqmul(zeta, r[temp + len1]);
      }
    }
  }

  for(j = 0; j < 256; ++j)
    r[j] = fqmul(r[j], zetas_inv[127]);
}

#elif (NTT_PROTECTION_MODE == COARSE_SHUFFLING)

// Coarse Shuffling...

void invntt(int16_t r[256])
{
  unsigned int start, len, j, k;
  int16_t t, zeta;
  uint8_t temp, stage;

  k = 0;
  stage = 0;
  for(len = 2; len <= 128; len <<= 1)
  {
    randomize(&multi_ordered_array[6][0], 128);
    for(start = 0; start < 128; start++)
    {
      // inverse_twiddle_factor_index_array
      // inverse_index_array

      temp = multi_ordered_array[6][start];
      zeta = zetas_inv[inverse_twiddle_factor_index_array[stage][temp]];
      temp = inverse_index_array[stage][temp];
      // printf("Start: %d, temp = %d, temp+len = %d, twiddle = %d\n",start,temp,temp + len,(inverse_twiddle_factor_index_array[stage][temp]));

      t = r[temp];
      r[temp] = barrett_reduce(t + r[temp + len]);
      r[temp + len] = t - r[temp + len];
      r[temp + len] = fqmul(zeta, r[temp + len]);

    }
    stage = stage+1;
  }

  for(j = 0; j < 256; ++j)
    r[j] = fqmul(r[j], zetas_inv[127]);
}

#elif (NTT_PROTECTION_MODE == GROUP_SHUFFLING)

void invntt(int16_t r[256])
{
  unsigned int start, len, j, k, g;
  int16_t t, zeta;
  uint8_t len1,temp,no_groups,row_no,stage;

  k = 0;
  stage = 0;
  for(len = 1; len <= 7; len++)
  {
    len1 = (1 << len);
    no_groups = 128/len1;
    row_no = 7-len;
    if(no_groups > 1)
    {
      randomize(&(multi_ordered_array_dup[row_no][0]), no_groups);

      for(g = 0; g < no_groups; g++)
      {
          start = (multi_ordered_array_dup[row_no][g])*2*len1;
          zeta = zetas_inv[inverse_twiddle_factor_index_array[stage][start/2]];

          for(j = start; j < start + len1; ++j)
          {
            t = r[j];
            r[j] = barrett_reduce(t + r[j + len1]);
            r[j + len1] = t - r[j + len1];
            r[j + len1] = fqmul(zeta, r[j + len1]);
          }
      }
    }
    else
    {
      // randomize(&(multi_ordered_array[6][0]), 128);
      randomize(ordered_array, 128);
      for(start = 0; start < 128; start++)
      {
        // temp = multi_ordered_array[6][start];
        temp = ordered_array[start];
        zeta = zetas_inv[inverse_twiddle_factor_index_array[stage][temp]];
        temp = inverse_index_array[stage][temp];

        t = r[temp];
        r[temp] = barrett_reduce(t + r[temp + len1]);
        r[temp + len1] = t - r[temp + len1];
        r[temp + len1] = fqmul(zeta, r[temp + len1]);

      }
    }
    stage = stage+1;
  }

  for(j = 0; j < 256; ++j)
    r[j] = fqmul(r[j], zetas_inv[127]);
}

#elif (NTT_PROTECTION_MODE == FINE_SHUFFLING)

// Fine shuffling...

void invntt(int16_t r[256])
{
  unsigned int start, len, j, k;
  int16_t t, zeta, temp, op1, op2, out1, out2;
  uint8_t randi, bitrand;
  int16_t mask;

  k = 0;
  int count = 0;

  for(len = 2; len <= 128; len <<= 1)
  {
    for(start = 0; start < 256; start = j + len)
    {
      zeta = zetas_inv[k++];
      for(j = start; j < start + len; ++j)
      {
        if((count&0x7) == 0)
        {
          // randi = get_random();
          randombytes(&randi,1);
        }

        bitrand = (randi>>(count&0x7))&0x1;
        mask = -1*(bitrand);
        count = count+1;

        op1 = r[j+bitrand*len];
        op2 = r[j+(1-bitrand)*len];

        temp = (op1 ^ op2)&mask;
        op1 = op1 ^ temp;
        op2 = op2 ^ temp;

        t = op1;
        out1 = barrett_reduce(t + op2);
        op2 = t - op2;
        out2 = fqmul(zeta, op2);

        if((count&0x7) == 0)
        {
          // randi = get_random();
          randombytes(&randi,1);
        }

        bitrand = (randi>>(count&0x7))&0x1;
        mask = -1*(bitrand);
        count = count+1;

        temp = (out1 ^ out2)&mask;
        out1 = out1 ^ temp;
        out2 = out2 ^ temp;

        r[j+bitrand*len] = out1;
        r[j+(1-bitrand)*len] = out2;

      }
    }
  }

  for(j = 0; j < 256; ++j)
    r[j] = fqmul(r[j], zetas_inv[127]);
}

#elif (NTT_PROTECTION_MODE == COARSE_MULTIPLICATIVE_MASKING)

// Coarse multiplicative masking...

void invntt(int16_t r[256])
{
  unsigned int start, len, j, k;
  int16_t t, zeta1, zeta2;
  uint8_t index1, index2;
  uint8_t random_index;
  uint8_t stage = 0;

  // Performing side channel resistant Inverse NTT structure with different twiddle factors...
  int16_t random_twiddle_exponent[7]; //Generating random exponents for each stage...
  uint16_t sum_random_twiddle_exponent = 0;

  for(int i=0;i<(NO_STAGES-1);i++)
  {
    // random_index = get_random();
    randombytes(&random_index,1);
    random_twiddle_exponent[i] = (random_index)&((KYBER_N)-1);
    sum_random_twiddle_exponent += random_twiddle_exponent[i];
  }

  random_twiddle_exponent[6] = (KYBER_N) - (sum_random_twiddle_exponent&((KYBER_N)-1));

  k = 0;
  for(len = 2; len <= 128; len <<= 1)
  {
    for(start = 0; start < 256; start = j + len)
    {
      index1 = (inverse_zeta_order[k] + random_twiddle_exponent[stage])&0xFF;
      index2 = random_twiddle_exponent[stage];

      zeta1 = zetas_normal_order[index1];
      // printf("%d, ",zeta1);
      zeta2 = zetas_normal_order[index2];

      for(j = start; j < start + len; ++j)
      {
        t = r[j];
        r[j] = fqmul(zeta2, barrett_reduce(t + r[j + len]));
        r[j + len] = t - r[j + len];
        r[j + len] = fqmul(zeta1, r[j + len]);
      }
      k = k+1;
    }
    stage = stage+1;
  }
  // printf("\n");

  for(j = 0; j < 256; ++j)
    r[j] = fqmul(r[j], zetas_inv[127]);
}

#elif (NTT_PROTECTION_MODE == FINE_MULTIPLICATIVE_MASKING)

// Fine multiplicative masking...

void invntt(int16_t r[256])
{
  unsigned int start, len, j, k;
  int16_t t, zeta, zeta1, zeta2, zeta3, zeta4, t1, t2, t3, t4;
  uint8_t index1, index2, index3, index4;
  uint8_t temp;
  uint8_t stage = 0;
  uint8_t new_random_twiddle_index_1, new_random_twiddle_index_2;

  uint8_t random_index, ii1, ii2;

  // Performing side channel resistant Inverse NTT structure with different twiddle factors...
  int16_t random_twiddle_exponent[KYBER_N]; //Generating random exponents for each stage...
  uint16_t sum_random_twiddle_exponent = 0;

  for(int i=0;i<KYBER_N;i++)
  {
    // random_index = get_random();
    randombytes(&random_index,1);
    random_twiddle_exponent[i] = (random_index)&((KYBER_N)-1);
    r[i] = fqmul(r[i],zetas_normal_order[random_twiddle_exponent[i]]);
  }

  k = 0;
  for(len = 2; len <= 128; len <<= 1)
  {
    for(start = 0; start < 256; start = j + len)
    {
      random_index = inverse_zeta_order[k];

      for(j = start; j < start + len; ++j)
      {

        ii1 = 256 - random_twiddle_exponent[j];
        ii2 = 256 - random_twiddle_exponent[j+len];

        if(len == 128)
        {
          index1 = ii1; //A1
          index2 = ii2; // B1
          index3 = (random_index + ii1)&0xFF; //A2
          index4 = (random_index + ii2)&0xFF; //B2
        }
        else
        {
          // new_random_twiddle_index_1 = get_random();
          randombytes(random_twiddle_exponent+j,1);
          // new_random_twiddle_index_2 = get_random();
          randombytes(random_twiddle_exponent+j+len,1);

          index1 = (ii1 + random_twiddle_exponent[j])&0xFF; //A1
          index2 = (ii2 + random_twiddle_exponent[j])&0xFF; // B1
          index3 = (random_index + ii1 + random_twiddle_exponent[j+len])&0xFF; //A2
          index4 = (random_index + ii2 + random_twiddle_exponent[j+len])&0xFF; //B2
        }

        zeta1 = zetas_normal_order[index1];
        zeta2 = zetas_normal_order[index2];
        zeta3 = zetas_normal_order[index3];
        zeta4 = zetas_normal_order[index4];

        t1 = fqmul(zeta1, r[j]);
        t2 = fqmul(zeta2, r[j+len]);
        t3 = fqmul(zeta3, r[j]);
        t4 = fqmul(zeta4, r[j + len]);

        r[j] = t1 + t2;
        r[j+len] = t3 - t4;
      }
      k = k+1;
    }
    // stage = stage+1;
  }
  // printf("\n");

  for(j = 0; j < 256; ++j)
    r[j] = fqmul(r[j], zetas_inv[127]);
}

#endif

/*************************************************
* Name:        basemul
*
* Description: Multiplication of polynomials in Zq[X]/(X^2-zeta)
*              used for multiplication of elements in Rq in NTT domain
*
* Arguments:   - int16_t r[2]:       pointer to the output polynomial
*              - const int16_t a[2]: pointer to the first factor
*              - const int16_t b[2]: pointer to the second factor
*              - int16_t zeta:       integer defining the reduction polynomial
**************************************************/
void basemul(int16_t r[2],
             const int16_t a[2],
             const int16_t b[2],
             int16_t zeta)
{
  r[0]  = fqmul(a[1], b[1]);
  r[0]  = fqmul(r[0], zeta);
  r[0] += fqmul(a[0], b[0]);

  r[1]  = fqmul(a[0], b[1]);
  r[1] += fqmul(a[1], b[0]);
}
